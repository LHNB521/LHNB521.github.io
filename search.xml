<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTMLDOM</title>
      <link href="2021/01/02/htmldom/"/>
      <url>2021/01/02/htmldom/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介"></a>HTML DOM 简介</h1><p><strong>HTML DOM定义了访问和操作HTML文档标准</strong><br>如果想要学习该知识用该具备的知识：</p><ul><li>HTML</li><li>CSS</li><li>JavaScript<h1 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h1></li></ul><p><strong>DOM是W3C（万维网联盟）的标准。</strong><br>DOM定义了访问HTML和XML文档的标准：<br>“W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”<br>W3C DOM标准被分为3个不同的部分：</p><ul><li>核心DOM - 针对任何结构化文档的标准模型</li><li>XML DOM - 针对XML文档的标准模型</li><li>HTML DOM - 针对HTML文档的标准模型<h1 id="什么是HTML-DOM？"><a href="#什么是HTML-DOM？" class="headerlink" title="什么是HTML DOM？"></a>什么是HTML DOM？</h1>HTML DOM是：</li><li>HTML的标准对象模型</li><li>HTML的标准编程接口</li><li>W3C标准<br>HTML DOM定义了所有HTML元素的<strong>对象</strong>和<strong>属性</strong>，以及访问他们的<strong>方法</strong>。</li><li>*HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准。**<h1 id="HTML-DOM节点"><a href="#HTML-DOM节点" class="headerlink" title="HTML DOM节点"></a>HTML DOM节点</h1></li><li>*在HTML DOM中，所有事物都是节点。DOM是被视为节点树的HTML。**<h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点：</li><li>整个文档是一个文档节点</li><li>每个HTML元素是元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性是属性节点</li><li>注释是注释节点<h2 id="HTML-DOM节点树"><a href="#HTML-DOM节点树" class="headerlink" title="HTML DOM节点树"></a>HTML DOM节点树</h2>HTML DOM将HTML文档视作树结构，这种接否被称为<strong>节点树：</strong></li><li>*HTML DOM Tree实例**<br><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="HTML DOM"><br>通过HTML DOM，树中的所有节点均可通过JavaScript进行访问。所有HTML元素（节点）均可被修改，也可以被创建和删除。<h2 id="节点父、子和同胞"><a href="#节点父、子和同胞" class="headerlink" title="节点父、子和同胞"></a>节点父、子和同胞</h2>节点树中的节点彼此拥有层级关系。<br>父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞节点（兄弟或姐妹）。</li><li>在节点树中，顶端节点被称为根（root）</li><li>每个节点都有父节点、除了根节点（他没有父节点）</li><li>一个节点可拥有任意数量的子</li><li>同胞是拥有形同父节点的节点<br>树的一部分，以及节点之间的关系：<br><img src="https://www.w3school.com.cn/i/dom_navigate.gif" alt="节点 关系"></li><li>*看下面的HTML代码片段：**<pre class=" language-HTML"><code class="language-HTML"><html>   <head>       <title>DOM 教程</title>   </head>   <body>       <h1>第一课</h1>       <p>Hello world!</P>   </body></html></code></pre>上面的HTML中：</li><li><html>节点没有父节点；它是根节点</li><li><head>和<body>的父节点是<html>节点</li><li>文本节点”Hello world!”的父节点是<p>节点<br>并且：</li><li><html>节点拥有两个子节点：<head>和<body></li><li><head>节点拥有一个子节点：<title>节点</li><li>&lt;title&gt;节点也拥有一个子节点：文本节点”DOM教程”</li><li>&lt;h1&gt;和<p>节点是同胞节点，同时也是<body>的子节点<h1 id="HTML-DOM-方法"><a href="#HTML-DOM-方法" class="headerlink" title="HTML DOM 方法"></a>HTML DOM 方法</h1></li><li>*方法是我们可以在节点（HTML元素）上执行的动作。**<h2 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h2>可以通过JavaScript（以及其他编程语言）对HTML DOM进行访问。<br>所有HTML元素被定义为对象，而编程接口则是对象方法和对象属性。<br>方法是您能够执行的动作（比如添加或修改元素）<br>属性是您能够获取或设置的值（比如节点的名称或内容）。<h3 id="getElementById-方法"><a href="#getElementById-方法" class="headerlink" title="getElementById()方法"></a>getElementById()方法</h3>getElementById()方法返回带有指定ID的元素：</li><li>*例子**</li></ul><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> element<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"intro"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="HTML-DOM对象-方法和属性"><a href="#HTML-DOM对象-方法和属性" class="headerlink" title="HTML DOM对象 - 方法和属性"></a>HTML DOM对象 - 方法和属性</h3><p>一些常用的HTML DOM方法：</p><ul><li>getElementById(id) - 获取带有指定ID的节点（元素）</li><li>appendChild(node) - 插入新的子节点（元素）</li><li>removeChild(node) - 删除子节点（元素）<br>一些常用的HTML DOM属性：</li><li>innerHTML - 节点（元素）的文本值</li><li>parentNode - 节点（元素）的父节点</li><li>childNodes - 节点（元素）的子节点</li><li>attribute - 节点（元素）的属性节点<h2 id="一些DOM对象方法"><a href="#一些DOM对象方法" class="headerlink" title="一些DOM对象方法"></a>一些DOM对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getElementById()</td><td>返回带有指定ID的元素</td></tr><tr><td>getElementByTagName()</td><td>返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。</td></tr><tr><td>getElementByClassName()</td><td>返回包含带有指定雷鸣的所有的节点列表</td></tr><tr><td>appendChild()</td><td>把新的子节点添加到指定节点。</td></tr><tr><td>removeChild()</td><td>删除子节点 。</td></tr><tr><td>replaceChild()</td><td>替换子节点</td></tr><tr><td>insertBefore()</td><td>在指定的子节点前面插入新的子节点</td></tr><tr><td>createAttribute()</td><td>创建属性节点</td></tr><tr><td>createElement()</td><td>创建元素节点</td></tr><tr><td>createTextNode()</td><td>创建文本节点</td></tr><tr><td>getAttribute()</td><td>返回指定属性值</td></tr><tr><td>setAttribute()</td><td>把指定属性设置或修改为指定的值</td></tr></tbody></table></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组去重</title>
      <link href="2020/12/30/javascript-shu-zu-qu-chong/"/>
      <url>2020/12/30/javascript-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<p>数组去重，一般都是在面试题上看到，一般是要求手写数组去重方法的代码。如果被提问到数组去重的方法有哪些？如果你能回答出十种方法，面试官可能会对你刮目相看。<br>    在真实的项目中碰到的数组去重，一般都是后台去处理，很好让前端处理数组去重。虽然日常项目用到的概率比降低，但还是需要了解一下，以防面试的时候可能回被问到。</p><h2 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h2><h3 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    return Array.from(new Set(arr))}var arr=[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]</code></pre><p><strong>注：不考虑兼容性，这种去重的方法代码最少。这种方法还是无法去掉“{}”空对象，后面的高级方法会添加去掉重复的“{}”的方法。</strong></p><h3 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    for(var i=0;i<arr.length;i++){        for(var j=i+1;j<arr.length;j++){            if(arr[i]==arr[j]){                arr.splice(j,1);                j--;            }        }    }    return arr;}var arr=[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(arr)//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</code></pre><p><strong>双层循环，外层循环元素，内层循环时比较值。值相同时，则删除这个值。</strong></p><h3 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    if(!Array.isArray(arr)){        console.log('不是数组')        return    }    var array=[];    for(var i=0; i<arr.length;i++){        if(array.indexOf(arr[i])==-1){            array.push(arr[i])        }    }    return array;}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重</code></pre><p><strong>新建一个空的结果数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进树组。</strong></p><h3 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    if(!Array.isArray(arr)){        console.log('不是数组')        return    }    arr = arr.sort()    var array = [arr[0]];    for(var i =1; i<arr.length; i++){        if(arr[i]!==arr[i-1]){            array.push(arr[i])        }    }    return array}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重</code></pre><p><strong>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</strong></p><h3 id="五、利用includes"><a href="#五、利用includes" class="headerlink" title="五、利用includes"></a>五、利用includes</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    if(!Array.isArray(arr)){        return     }    var array= [];    for(var i=0;i<arr.length;i++){        if(!array.includes(arr[i])){            array.push(arr[i]);        }    }    return array;}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]     //{}没有去重</code></pre><h3 id="六、利用hasOwnProperty"><a href="#六、利用hasOwnProperty" class="headerlink" title="六、利用hasOwnProperty"></a>六、利用hasOwnProperty</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    var obj = {};    return arr.filter(function(item,index,arr){        return obj.hasOwnProperty(typeof item+item)?fasle : (obj[typeof item + item]=true)    })}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];        console.log(unique(arr))//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了</code></pre><p><strong>利用hasOwnPeoperty判断是否存在对象属性</strong></p><h3 id="七、利用filter"><a href="#七、利用filter" class="headerlink" title="七、利用filter"></a>七、利用filter</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    return arr.filter(function(item,index,arr){        //当前元素，在原始数组中的第一个索引==当前索引，否则返回当前元素        return arr.indexOf(item,0)===index;    });}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]</code></pre><h3 id="八、利用递归去重"><a href="#八、利用递归去重" class="headerlink" title="八、利用递归去重"></a>八、利用递归去重</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    var array=arr;    var len=array.length;    array.sort(function(a,b){    //排序后更加方便去重        return a,b;    })    function loop(index){        if(index>=1){            if(array[index]===array[index-1]){                array.splice(index,1);            }            loop(index,1);        }    }    loop(len-1);    return array;}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]</code></pre><h3 id="九、利用Map数据结构去重"><a href="#九、利用Map数据结构去重" class="headerlink" title="九、利用Map数据结构去重"></a>九、利用Map数据结构去重</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    let map = new Map();    let array = new Array();   //数组用于返回结果    for(let i = 0; i< arr.length; i++){        if(map.has(arr[i])){    //如果有该key值            map.set(arr[i],true);        }else{         map.set(arr[i],false);     //如果没有key值         array.push(arr[i]);        }    }    return array;}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr))//[1, "a", "true", true, 15, false, 1, {…}, null, NaN, NaN, "NaN", 0, "a", {…}, undefined]</code></pre><p><strong>创建一个空的Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现不同的key值，所以最终得到的结果就是去重后的结果。</strong></p><h3 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h3><pre class=" language-JavaScript"><code class="language-JavaScript">function unique(arr){    return arr.reduce((prev,cur)=>prev,includes(cur)?prev:[...prev,cur],[]);}var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];console.log(unique(arr));// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}, {…}]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaSctipt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
