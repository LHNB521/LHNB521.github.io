<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谈到首屏优化，都能说些什么</title>
      <link href="2023/01/30/tan-dao-shou-ping-you-hua-du-neng-shuo-xie-shi-me/"/>
      <url>2023/01/30/tan-dao-shou-ping-you-hua-du-neng-shuo-xie-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="谈到首屏优化，都能说些什么"><a href="#谈到首屏优化，都能说些什么" class="headerlink" title="谈到首屏优化，都能说些什么"></a>谈到首屏优化，都能说些什么</h1><blockquote><h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>如何进行首屏优化，路由懒加载，服务端渲染SSR，预加载，分页分片，图片懒加载，性能优化就是让加载更快，让渲染更快</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天带来的依旧是一道<strong>场景八股题</strong>，很常问，也很重要：</p><ul><li>  <strong>如何进行首屏优化</strong></li></ul><p>看到这里如果你脑子里突然出现了第一、第二….首先、其次….等词的时候，大佬，请收下我的膝盖！</p><p>如果没出现，那就慢慢听我道来..</p><p>说到首屏优化，我们大家对于性能优化还是要有一个基本认识的，如何进行性能优化，该从何下手呢？</p><p>我的答案是：<strong>让加载更快，让渲染更快</strong></p><blockquote><p>举个例子：我们在搭建博客的时候会使用到配图，图片非常多的时候，我们进入博客的时候是不是会转圈转很久？</p><p>那么我们这里是如何解决的？ 是不是大部分人都会用到<strong>CDN</strong>啊，就是使得图片的加载更快，达到了我们优化的目的。</p></blockquote><p>接下来我们一起看看首屏优化可以使用什么方法吧</p><p>如果你有更好的方法或者我的说法哪里有误，欢迎在评论区指出 or 提出，希望可以同大家一起进步！</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="路由懒加载-适用于SPA应用"><a href="#路由懒加载-适用于SPA应用" class="headerlink" title="路由懒加载 适用于SPA应用"></a>路由懒加载 适用于SPA应用</h3><p>路由懒加载，即按需加载或延迟加载，要将路由进行拆分，优先保证首页加载。</p><p>由于Vue是SPA（单页面）应用，他在打包之后会有一个巨大的js包，我们进入首页的时候为了加载资源就会造成一个白屏的情况，即使是做了加载动画，添加了Loading，用户的体验也不是很好，会觉得网站很卡，所以我们将其进行拆分，用到的时候，让他加载，没有用到的时候，就不用加载，这样加载的资源少了，速度自然就提高了。</p><p>我们之前在vue中写路由的时候可能是这么写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [ </span><br><span class="line">            &#123; </span><br><span class="line">                path: &#39;&#x2F;&#39;,</span><br><span class="line">                name: &#39;Ned&#39;, </span><br><span class="line">                component: Ned </span><br><span class="line">             &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>现在我们可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [ </span><br><span class="line">            &#123; </span><br><span class="line">                path: &#39;&#x2F;&#39;,</span><br><span class="line">                name: &#39;Ned&#39;, </span><br><span class="line">                component: ()&#x3D;&gt;import(&quot;@&#x2F;components&#x2F;Ned&quot;)</span><br><span class="line">             &#125;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><p>我们这么写只是进行了组件的注册，但没有进行加载，只有等到需要这个组件的时候，才会加载执行。</p><h3 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h3><p>这里可以了解一下，浏览器端渲染（CSR）和服务器端渲染（SSR）都分别是什么。</p><ul><li>  CSR: 页面上的内容是我们加载的js文件渲染出来的，js文件运行在浏览器上面，服务端只返回一个html模板</li><li>  SSR：页面上的内容是通过服务端渲染生成的，浏览器直接显示服务端返回的html就可以了</li></ul><p>那么为什么首屏加载要使用SSR呢？</p><p>我们在浏览器渲染的时候，我们会依次的去下载资源，我们想要成功看见页面，就需要将app.js这种文件下载到本地，在此之前我们看见的都会是白屏，而服务端渲染则不同，它返回的直接就是一个完整的html网页，可以直接显示在浏览器上。</p><p>导致浏览器渲染在首屏加载上弱于服务端渲染的原因就在于：<strong>控制页面的js文件没加载出来之前，我们是看不见页面的</strong></p><blockquote><p>但是服务端渲染是有成本的，所以大家要具体情况具体分析，当然面试的时候我们是可以说出来这点的</p></blockquote><h3 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h3><p>就是用户还没用呢，我先去下载过来，当用户使用的时候，就会瞬间打开，贼快！</p><blockquote><p>但是这个跟首屏（指的是首页，第一页）优化好像没什么关系，这个的场景可以说是公众号的文章列表，或者浏览器导航类网页，去加速后续页面的读取速度</p></blockquote><p>当用户进入导航类页面的时候，会在服务器端进行一个预下载的配置，去下载静态资源，完后当用户点击到已经下载的应用链接的时候，就会瞬间打开</p><blockquote><p>我预判了你的预判！</p></blockquote><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>当我们的表单数据有非常多时，我们可以将其进行分页，默认出现在首页的只有第一页的数据，想看到另外的数据可以让用户触发下滑之类的操作，再去加载另外的数据</p><p>这跟如何一次性在页面渲染十万条数据我觉得有相同之处，当后端给我们一次性返回十万条数据让我们进行渲染的时候（<del>不要犹豫，抄家伙</del>）</p><p>我们可以对数据进行分片，配合setTimeout让数据分批次进行加载，后续可以使用<code>window.requestAnimationFrame()</code>函数减少重排，也可以用文档碎片<code>document.createDocumentFragment()</code>的方式进行再度优化</p><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>首先我们需要让我们 html 中需要懒加载的 img 标签的 src 设置缩略图或者不设置 src，然后自定义一个属性，值为真正的图片或者原图的地址（比如 data-src），并且定义一个类名，表示该图片是需要懒加载的（比如lazy-img），这有两个作用：</p><ul><li>  为以后获取需要懒加载图片的 img 元素</li><li>  可以给这个类名设置背景图片，作为图片未加载前的过度图片，比如显示为 loading 的图片。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img data-src&#x3D;&quot;真实地址&quot; class&#x3D;&quot;lazy-img&quot;&gt;</span><br></pre></td></tr></table></figure><p>页面加载完后，我们需要获取所有需要懒加载的图片的元素集合，判断是否在可视区域，如果是在<strong>可视区域</strong>的话，设置元素的 src 属性值为<strong>真正图片的地址</strong>。</p><p>当用户滚动窗口的时候，遍历所有需要懒加载的元素，通过每个元素的 <code>BoundingClientRect</code> 属性来判断元素是否出现在可视区域内，判断方法同之前一步一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;scroll&#39;, inViewShow)</span><br></pre></td></tr></table></figure><p>这里我们还可以优化下，可以通过函数节流优化滚动事件的处理函数</p><blockquote><p>还有要注意的就是要提前设置图片尺寸，尽量只重绘，不重排</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>我们在做性能优化的时候，要积极配合统计分析，要得出优化结果，不管是在晋升还是在面试上，都要体现在文本上，例如从10s优化到了1s等等，另外还要让用户有体验感，如骨架屏，loading动画等</p><p>其次针对于不同形式有不同的优化方式，不要一股脑的全部堆上去，有可能会适得其反。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33个非常实用的JavaScript一行代码</title>
      <link href="2022/05/20/33-ge-fei-chang-shi-yong-de-javascript-yi-xing-dai-ma/"/>
      <url>2022/05/20/33-ge-fei-chang-shi-yong-de-javascript-yi-xing-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="一、日期处理"><a href="#一、日期处理" class="headerlink" title="一、日期处理"></a>一、日期处理</h2><h3 id="1-检查日期是否有效"><a href="#1-检查日期是否有效" class="headerlink" title="1. 检查日期是否有效"></a>1. 检查日期是否有效</h3><p>该方法用于检测给出的日期是否有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isDateValid &#x3D; (...val) &#x3D;&gt; !Number.isNaN(new Date(...val).valueOf());</span><br><span class="line"></span><br><span class="line">isDateValid(&quot;December 17, 1995 03:24:00&quot;);  &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-计算两个日期之间的间隔"><a href="#2-计算两个日期之间的间隔" class="headerlink" title="2. 计算两个日期之间的间隔"></a>2. 计算两个日期之间的间隔</h3><p>该方法用于计算两个日期之间的间隔时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const dayDif &#x3D; (date1, date2) &#x3D;&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) &#x2F; 86400000)</span><br><span class="line">    </span><br><span class="line">dayDif(new Date(&quot;2021-11-3&quot;), new Date(&quot;2022-2-1&quot;))  &#x2F;&#x2F; 90</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>距离过年还有90天~</p><h3 id="3-查找日期位于一年中的第几天"><a href="#3-查找日期位于一年中的第几天" class="headerlink" title="3. 查找日期位于一年中的第几天"></a>3. 查找日期位于一年中的第几天</h3><p>该方法用于检测给出的日期位于今年的第几天：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const dayOfYear &#x3D; (date) &#x3D;&gt; Math.floor((date - new Date(date.getFullYear(), 0, 0)) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24);</span><br><span class="line"></span><br><span class="line">dayOfYear(new Date());   &#x2F;&#x2F; 307</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2021年已经过去300多天了~</p><h3 id="4-时间格式化"><a href="#4-时间格式化" class="headerlink" title="4. 时间格式化"></a>4. 时间格式化</h3><p>该方法可以用于将时间转化为hour:minutes:seconds的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const timeFromDate &#x3D; date &#x3D;&gt; date.toTimeString().slice(0, 8);</span><br><span class="line">    </span><br><span class="line">timeFromDate(new Date(2021, 11, 2, 12, 30, 0));  &#x2F;&#x2F; 12:30:00</span><br><span class="line">timeFromDate(new Date());  &#x2F;&#x2F; 返回当前时间 09:00:00</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="二、字符串处理"><a href="#二、字符串处理" class="headerlink" title="二、字符串处理"></a>二、字符串处理</h2><h3 id="1-字符串首字母大写"><a href="#1-字符串首字母大写" class="headerlink" title="1. 字符串首字母大写"></a>1. 字符串首字母大写</h3><p>该方法用于将英文字符串的首字母大写处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const capitalize &#x3D; str &#x3D;&gt; str.charAt(0).toUpperCase() + str.slice(1)</span><br><span class="line"></span><br><span class="line">capitalize(&quot;hello world&quot;)  &#x2F;&#x2F; Hello world</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-翻转字符串"><a href="#2-翻转字符串" class="headerlink" title="2. 翻转字符串"></a>2. 翻转字符串</h3><p>该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const reverse &#x3D; str &#x3D;&gt; str.split(&#39;&#39;).reverse().join(&#39;&#39;);</span><br><span class="line"></span><br><span class="line">reverse(&#39;hello world&#39;);   &#x2F;&#x2F; &#39;dlrow olleh&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-随机字符串"><a href="#3-随机字符串" class="headerlink" title="3. 随机字符串"></a>3. 随机字符串</h3><p>该方法用于生成一个随机的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const randomString &#x3D; () &#x3D;&gt; Math.random().toString(36).slice(2);</span><br><span class="line"></span><br><span class="line">randomString();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-截断字符串"><a href="#4-截断字符串" class="headerlink" title="4. 截断字符串"></a>4. 截断字符串</h3><p>该方法可以从指定长度处截断字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const truncateString &#x3D; (string, length) &#x3D;&gt; string.length &lt; length ? string : &#96;$&#123;string.slice(0, length - 3)&#125;...&#96;;</span><br><span class="line"></span><br><span class="line">truncateString(&#39;Hi, I should be truncated because I am too loooong!&#39;, 36)   &#x2F;&#x2F; &#39;Hi, I should be truncated because...&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-去除字符串中的HTML"><a href="#5-去除字符串中的HTML" class="headerlink" title="5. 去除字符串中的HTML"></a>5. 去除字符串中的HTML</h3><p>该方法用于去除字符串中的HTML元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const stripHtml &#x3D; html &#x3D;&gt; (new DOMParser().parseFromString(html, &#39;text&#x2F;html&#39;)).body.textContent || &#39;&#39;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="三、数组处理"><a href="#三、数组处理" class="headerlink" title="三、数组处理"></a>三、数组处理</h2><h3 id="1-从数组中移除重复项"><a href="#1-从数组中移除重复项" class="headerlink" title="1. 从数组中移除重复项"></a>1. 从数组中移除重复项</h3><p>该方法用于移除数组中的重复项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const removeDuplicates &#x3D; (arr) &#x3D;&gt; [...new Set(arr)];</span><br><span class="line"></span><br><span class="line">console.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-判断数组是否为空"><a href="#2-判断数组是否为空" class="headerlink" title="2. 判断数组是否为空"></a>2. 判断数组是否为空</h3><p>该方法用于判断一个数组是否为空数组，它将返回一个布尔值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isNotEmpty &#x3D; arr &#x3D;&gt; Array.isArray(arr) &amp;&amp; arr.length &gt; 0;</span><br><span class="line"></span><br><span class="line">isNotEmpty([1, 2, 3]);  &#x2F;&#x2F; true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-合并两个数组"><a href="#3-合并两个数组" class="headerlink" title="3. 合并两个数组"></a>3. 合并两个数组</h3><p>可以使用下面两个方法来合并两个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const merge &#x3D; (a, b) &#x3D;&gt; a.concat(b);</span><br><span class="line"></span><br><span class="line">const merge &#x3D; (a, b) &#x3D;&gt; [...a, ...b];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="四、数字操作"><a href="#四、数字操作" class="headerlink" title="四、数字操作"></a>四、数字操作</h2><h3 id="1-判断一个数是奇数还是偶数"><a href="#1-判断一个数是奇数还是偶数" class="headerlink" title="1. 判断一个数是奇数还是偶数"></a>1. 判断一个数是奇数还是偶数</h3><p>该方法用于判断一个数字是奇数还是偶数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isEven &#x3D; num &#x3D;&gt; num % 2 &#x3D;&#x3D;&#x3D; 0;</span><br><span class="line"></span><br><span class="line">isEven(996); </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-获得一组数的平均值"><a href="#2-获得一组数的平均值" class="headerlink" title="2. 获得一组数的平均值"></a>2. 获得一组数的平均值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const average &#x3D; (...args) &#x3D;&gt; args.reduce((a, b) &#x3D;&gt; a + b) &#x2F; args.length;</span><br><span class="line"></span><br><span class="line">average(1, 2, 3, 4, 5);   &#x2F;&#x2F; 3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-获取两个整数之间的随机整数"><a href="#3-获取两个整数之间的随机整数" class="headerlink" title="3. 获取两个整数之间的随机整数"></a>3. 获取两个整数之间的随机整数</h3><p>该方法用于获取两个整数之间的随机整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const random &#x3D; (min, max) &#x3D;&gt; Math.floor(Math.random() * (max - min + 1) + min);</span><br><span class="line"></span><br><span class="line">random(1, 50);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-指定位数四舍五入"><a href="#4-指定位数四舍五入" class="headerlink" title="4. 指定位数四舍五入"></a>4. 指定位数四舍五入</h3><p>该方法用于将一个数字按照指定位进行四舍五入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const round &#x3D; (n, d) &#x3D;&gt; Number(Math.round(n + &quot;e&quot; + d) + &quot;e-&quot; + d)</span><br><span class="line"></span><br><span class="line">round(1.005, 2) &#x2F;&#x2F;1.01</span><br><span class="line">round(1.555, 2) &#x2F;&#x2F;1.56</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="五、颜色操作"><a href="#五、颜色操作" class="headerlink" title="五、颜色操作"></a>五、颜色操作</h2><h3 id="1-将RGB转化为十六机制"><a href="#1-将RGB转化为十六机制" class="headerlink" title="1. 将RGB转化为十六机制"></a>1. 将RGB转化为十六机制</h3><p>该方法可以将一个RGB的颜色值转化为16进制值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const rgbToHex &#x3D; (r, g, b) &#x3D;&gt; &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1);</span><br><span class="line"></span><br><span class="line">rgbToHex(255, 255, 255);  &#x2F;&#x2F; &#39;#ffffff&#39;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-获取随机十六进制颜色"><a href="#2-获取随机十六进制颜色" class="headerlink" title="2. 获取随机十六进制颜色"></a>2. 获取随机十六进制颜色</h3><p>该方法用于获取一个随机的十六进制颜色值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const randomHex &#x3D; () &#x3D;&gt; &#96;#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;)&#125;&#96;;</span><br><span class="line"></span><br><span class="line">randomHex();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="六、浏览器操作"><a href="#六、浏览器操作" class="headerlink" title="六、浏览器操作"></a>六、浏览器操作</h2><h3 id="1-复制内容到剪切板"><a href="#1-复制内容到剪切板" class="headerlink" title="1. 复制内容到剪切板"></a>1. 复制内容到剪切板</h3><p>该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const copyToClipboard &#x3D; (text) &#x3D;&gt; navigator.clipboard.writeText(text);</span><br><span class="line"></span><br><span class="line">copyToClipboard(&quot;Hello World&quot;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-清除所有cookie"><a href="#2-清除所有cookie" class="headerlink" title="2. 清除所有cookie"></a>2. 清除所有cookie</h3><p>该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const clearCookies &#x3D; document.cookie.split(&#39;;&#39;).forEach(cookie &#x3D;&gt; document.cookie &#x3D; cookie.replace(&#x2F;^ +&#x2F;, &#39;&#39;).replace(&#x2F;&#x3D;.*&#x2F;, &#96;&#x3D;;expires&#x3D;$&#123;new Date(0).toUTCString()&#125;;path&#x3D;&#x2F;&#96;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-获取选中的文本"><a href="#3-获取选中的文本" class="headerlink" title="3. 获取选中的文本"></a>3. 获取选中的文本</h3><p>该方法通过内置的 getSelection 属性获取用户选择的文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const getSelectedText &#x3D; () &#x3D;&gt; window.getSelection().toString();</span><br><span class="line"></span><br><span class="line">getSelectedText();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-检测是否是黑暗模式"><a href="#4-检测是否是黑暗模式" class="headerlink" title="4. 检测是否是黑暗模式"></a>4. 检测是否是黑暗模式</h3><p>该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isDarkMode &#x3D; window.matchMedia &amp;&amp; window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches</span><br><span class="line"></span><br><span class="line">console.log(isDarkMode)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-滚动到页面顶部"><a href="#5-滚动到页面顶部" class="headerlink" title="5. 滚动到页面顶部"></a>5. 滚动到页面顶部</h3><p>该方法用于在页面中返回顶部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const goToTop &#x3D; () &#x3D;&gt; window.scrollTo(0, 0);</span><br><span class="line"></span><br><span class="line">goToTop();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-判断当前标签页是否激活"><a href="#6-判断当前标签页是否激活" class="headerlink" title="6. 判断当前标签页是否激活"></a>6. 判断当前标签页是否激活</h3><p>该方法用于检测当前标签页是否已经激活：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isTabInView &#x3D; () &#x3D;&gt; !document.hidden; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="7-判断当前是否是苹果设备"><a href="#7-判断当前是否是苹果设备" class="headerlink" title="7. 判断当前是否是苹果设备"></a>7. 判断当前是否是苹果设备</h3><p>该方法用于检测当前的设备是否是苹果的设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const isAppleDevice &#x3D; () &#x3D;&gt; &#x2F;Mac|iPod|iPhone|iPad&#x2F;.test(navigator.platform);</span><br><span class="line"></span><br><span class="line">isAppleDevice();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="8-是否滚动到页面底部"><a href="#8-是否滚动到页面底部" class="headerlink" title="8. 是否滚动到页面底部"></a>8. 是否滚动到页面底部</h3><p>该方法用于判断页面是否已经底部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const scrolledToBottom &#x3D; () &#x3D;&gt; document.documentElement.clientHeight + window.scrollY &gt;&#x3D; document.documentElement.scrollHeight;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="9-重定向到一个URL"><a href="#9-重定向到一个URL" class="headerlink" title="9. 重定向到一个URL"></a>9. 重定向到一个URL</h3><p>该方法用于重定向到一个新的URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const redirect &#x3D; url &#x3D;&gt; location.href &#x3D; url</span><br><span class="line"></span><br><span class="line">redirect(&quot;https:&#x2F;&#x2F;www.google.com&#x2F;&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="10-打开浏览器打印框"><a href="#10-打开浏览器打印框" class="headerlink" title="10. 打开浏览器打印框"></a>10. 打开浏览器打印框</h3><p>该方法用于打开浏览器的打印框：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const showPrintDialog &#x3D; () &#x3D;&gt; window.print()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="七、其他操作"><a href="#七、其他操作" class="headerlink" title="七、其他操作"></a>七、其他操作</h2><h3 id="1-随机布尔值"><a href="#1-随机布尔值" class="headerlink" title="1. 随机布尔值"></a>1. 随机布尔值</h3><p>该方法可以返回一个随机的布尔值，使用Math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const randomBoolean &#x3D; () &#x3D;&gt; Math.random() &gt;&#x3D; 0.5;</span><br><span class="line"></span><br><span class="line">randomBoolean();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-变量交换"><a href="#2-变量交换" class="headerlink" title="2. 变量交换"></a>2. 变量交换</h3><p>可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[foo, bar] &#x3D; [bar, foo];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-获取变量的类型"><a href="#3-获取变量的类型" class="headerlink" title="3. 获取变量的类型"></a>3. 获取变量的类型</h3><p>该方法用于获取一个变量的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const trueTypeOf &#x3D; (obj) &#x3D;&gt; Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();</span><br><span class="line"></span><br><span class="line">trueTypeOf(&#39;&#39;);     &#x2F;&#x2F; string</span><br><span class="line">trueTypeOf(0);      &#x2F;&#x2F; number</span><br><span class="line">trueTypeOf();       &#x2F;&#x2F; undefined</span><br><span class="line">trueTypeOf(null);   &#x2F;&#x2F; null</span><br><span class="line">trueTypeOf(&#123;&#125;);     &#x2F;&#x2F; object</span><br><span class="line">trueTypeOf([]);     &#x2F;&#x2F; array</span><br><span class="line">trueTypeOf(0);      &#x2F;&#x2F; number</span><br><span class="line">trueTypeOf(() &#x3D;&gt; &#123;&#125;);  &#x2F;&#x2F; function</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-华氏度和摄氏度之间的转化"><a href="#4-华氏度和摄氏度之间的转化" class="headerlink" title="4. 华氏度和摄氏度之间的转化"></a>4. 华氏度和摄氏度之间的转化</h3><p>该方法用于摄氏度和华氏度之间的转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const celsiusToFahrenheit &#x3D; (celsius) &#x3D;&gt; celsius * 9&#x2F;5 + 32;</span><br><span class="line">const fahrenheitToCelsius &#x3D; (fahrenheit) &#x3D;&gt; (fahrenheit - 32) * 5&#x2F;9;</span><br><span class="line"></span><br><span class="line">celsiusToFahrenheit(15);    &#x2F;&#x2F; 59</span><br><span class="line">celsiusToFahrenheit(0);     &#x2F;&#x2F; 32</span><br><span class="line">celsiusToFahrenheit(-20);   &#x2F;&#x2F; -4</span><br><span class="line">fahrenheitToCelsius(59);    &#x2F;&#x2F; 15</span><br><span class="line">fahrenheitToCelsius(32);    &#x2F;&#x2F; 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-检测对象是否为空"><a href="#5-检测对象是否为空" class="headerlink" title="5. 检测对象是否为空"></a>5. 检测对象是否为空</h3><p>该方法用于检测一个JavaScript对象是否为空：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const isEmpty &#x3D; obj &#x3D;&gt; Reflect.ownKeys(obj).length &#x3D;&#x3D;&#x3D; 0 &amp;&amp; obj.constructor &#x3D;&#x3D;&#x3D; Object;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 生命周期详解</title>
      <link href="2022/05/11/react-sheng-ming-zhou-qi-xiang-jie/"/>
      <url>2022/05/11/react-sheng-ming-zhou-qi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>在 React 中，对于每一次由状态改变导致页面视图的改变，都会经历两个阶段：<code>render 阶段</code>、<code>commit 阶段</code>。</p><p>只有 class 组件才有生命周期，因为 class 组件会创建对应的实例，而函数组件不会。组件实例从被创建到被销毁的过程称为<strong>组件的生命周期</strong>。</p><p>由 class 组件创建的实例具有生命周期，它的 render 函数在 render 阶段执行，并在此阶段进行 DOM 节点的 diff（diff 算法就是在此阶段进行的），找出需要改变的 DOM 操作。然后在 commit 阶段将对应的 DOM 操作提交至视图中。</p><p>而 class 组件实例的所有生命周期函数，都会在 render 阶段和 commit 阶段执行。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5fa490ee4d948dba86a950bfe08dede~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"> <em>注：红色为 React 17 已经废弃的生命周期钩子，绿色为新增的生命周期钩子</em></p><p>在首次渲染页面时，会调用 Mount 相关生命周期钩子；在之后的页面渲染中，会调用 Update 相关生命周期钩子。所以与 Mount 相关的生命周期钩子只会被调用一次。</p><h2 id="render-阶段"><a href="#render-阶段" class="headerlink" title="render 阶段"></a>render 阶段</h2><p>render 阶段会执行众多生命周期钩子，例如：在首次渲染时执行 constructor、getDerivedStateFromProps、componentWillMount、render，在更新时执行 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render，在渲染阶段捕捉到了后代组件中的错误时会执行 getDerivedStateFromError。</p><p>接下来，看看这些生命周期钩子的调用时机，以及它们的作用。</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>该方法只会执行一次，调用该方法会返回一个组件实例。</p><p>在初始化阶段执行，可直接对 <code>this.state</code> 赋值。其他生命周期函数中只能通过 <code>this.setState</code> 修改 state，不能直接为 <code>this.state</code> 赋值。</p><p><strong>使用场景：</strong></p><p>一般在 constructor 中做一些组件的初始化工作，例如：初始化组件的 state。</p><h2 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a>componentWillReceiveProps</h2><p>在已挂载组件接收到新的 props 之前调用。你可以在这个函数中比较新旧 props，并根据新旧 props 更改 state。但是它会<strong>破坏 props 数据的单一数据源</strong>。</p><p>在首次渲染组件时，不会调用此生命周期钩子；使用 <code>this.setState</code> 触发组件更新时，也不会调用此生命周期钩子。</p><p>不过要<strong>注意</strong>：如果是父组件渲染导致了组件的重新渲染，即使传给该组件的 props 没变，该组件中的这个生命周期函数也会被调用。</p><p>我们一般不使用此生命周期函数，因为它通常会破坏数据源的单一性。</p><h2 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h2><p>它是一个<strong>静态方法</strong>，接收 propsprops 和 statestate 两个参数。它会在调用 render 方法之前被调用，不管是在初始挂载时还是在后续组件更新时都会被调用。</p><p>它的调用时机和 componentWillMount、componentWillUpdate、componentWillReceiveProps 一样都是在 render 方法被调用之前，它可以作为 componentWillMount、componentWillUpdate 和 componentWillReceiveProps 的替代方案。</p><p>当然，它的作用不止如此，它可以返回一个对象，用来更新 state，就像它的名字一样，从 props 中获取衍生的 state。如果不需要更新 state 则可以返回 null。</p><p>需要<strong>注意</strong>的是：这个生命周期函数是类的<strong>静态方法</strong>，并不是原型中的方法，所以在其内部使用 this 访问到的不是组件实例。</p><p>此生命周期钩子不常用，如果可以的话，我们也尽可能不会使用它。</p><p>关于为什么要废弃 componentWillMount、componentWillUpdate、componentWillReceiveProps 三个生命周期钩子而新增 getDerivedStateFromProps 生命周期钩子，后面会说明原因。</p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>在组件准备更新之前调用，但是首次渲染或者使用 forceUpdate 函数时不会被调用。跟它的名字一样，它用来判断一个组件是否应该更新。</p><p>默认情况下，当组件的 props 或者 state 变化时，都会导致组件更新。它在 render 方法之前执行，如果它的返回值为 false，则不会更新组件，也不会执行后面的 render 方法。</p><p>它接收两个参数，nextProps 和 nextState，即下一次更新的 props 和下一次更新的 state。我们可以将 <code>this.props</code> 和 nextProps 比较，以及将 <code>this.state</code> 与 nextState 比较，并返回 false，让组件跳过更新。不过<strong>注意</strong>：它并不会阻止子组件因为 state 改变而导致的更新。</p><p><strong>使用场景：</strong></p><p>这个生命周期方法通常用来做性能优化。</p><h2 id="componentWillMount（UNSAFE）"><a href="#componentWillMount（UNSAFE）" class="headerlink" title="componentWillMount（UNSAFE）"></a>componentWillMount（UNSAFE）</h2><p>在组件挂载至 DOM 之前调用，并且只会调用一次。它在 render 方法之前调用，因此在 componentWillMount 中调用 <code>this.setState</code> 不会触发额外的渲染。</p><p>这个生命周期钩子使用频率较小，因为我们一般在 constructor 中<strong>初始化 state</strong>，在 componentDidMount 中<strong>引入副作用</strong>或者<strong>订阅内容</strong>。</p><h2 id="componentWillUpdate（UNSAFE）"><a href="#componentWillUpdate（UNSAFE）" class="headerlink" title="componentWillUpdate（UNSAFE）"></a>componentWillUpdate（UNSAFE）</h2><p>在组件即将更新之前执行，如果 shouldComponentUpdate 函数返回 false，则不会调用 componentWillUpdate 方法。</p><p>这个生命周期钩子和 componentWillMount 类似，执行的时机是相同的，只不过 componentWillMount 在组件首次渲染时执行，而 componentWillUpdate 在组件后续更新时执行。这两个生命周期函数都不经常使用。</p><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>render 方法是类组件中唯一必须实现的方法，它的返回值将作为页面渲染的视图。render 函数应该为纯函数，也就是对于相同的 state 和 props，它总是返回相同的渲染结果。</p><p>render 函数被调用时，会返回以下四种类型之一：</p><ul><li>  React 元素：通常为 JSX 语法。例如：<code>&lt;div /&gt;</code>、<code>&lt;MyComponent&gt;</code> 等等。</li><li>  数组或者 fragments：render 方法可以通过数组返回多个元素。</li><li>  Portals：渲染子节点至不同的子树中。</li><li>  字符串或者数值：会作为文本节点被渲染。</li><li>  boolean 类型或者 null：什么都不渲染。</li></ul><p>需要<strong>注意</strong>的是：如果 shouldComponentUpdate 生命周期钩子返回 false，则 render 方法（render 阶段后续生命周期钩子）不会执行。</p><h2 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h2><p>commit 阶段在首次渲染时会执行 componentDidMount，在组件更新时会执行 getSnapshotBeforeUpdate 和 componentDidUpdate。</p><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>该生命周期方法会在组件挂载之后执行，也只会执行一次，也就是将组件对应的 DOM 插入 DOM 树中之后调用。它会在浏览器更新视图之前调用，如果在 componentDidMount 中<strong>直接调用</strong> <code>this.setState</code>，它会触发额外的渲染，会再一次调用 render 函数，但是浏览器中视图的更新只会执行一次。</p><p><strong>使用场景：</strong></p><p><strong>依赖于 DOM 的初始化</strong>操作应该放在这里，此外，我们一般在这个生命周期方法中<strong>发送网络请求</strong>、<strong>添加订阅</strong>等。</p><h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>此生命周期函数在最近一次渲染提交至 DOM 树之前执行，此时 DOM 树还未改变，我们可以在这里获取 DOM 改变前的信息，例如：更新前 DOM 的滚动位置。</p><p>它接收两个参数，分别是：prevProps、prevState，上一个状态的 props 和上一个状态的 state。它的返回值将会传递给 componentDidUpdate 生命周期钩子的第三个参数。</p><p><strong>使用场景：</strong></p><p>需要<strong>获取更新前 DOM 的信息</strong>时。例如：需要以特殊方式处理滚动位置的聊天线程等。</p><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>在组件更新后立即调用，首次渲染不会调用该方法。它的执行时机和 componentDidMount 一致，只是 componentDidMount 在首次渲染时调用，而 componentDidUpdate 在后续的组件更新时调用。可以在这个生命周期中直接调用 <code>this.setState</code>，但是必须包裹在一个条件语句中，否则会导致死循环。</p><p>componentDidUpdate 接收三个参数，分别是 prevProps、prevState、snapshot，即：前一个状态的 props，前一个状态的 state、getSnapshotBeforeUpdate 的返回值。</p><p>如果组件实现了 getSnapshotBeforeUpdate 生命周期函数，则 getSnapshotBeforeUpdate 的返回值将作为 componentDidUpdate 的第三个参数。</p><p><strong>使用场景：</strong></p><p>在这个生命周期方法中，可以<strong>对 DOM 进行操作</strong>或者进行<strong>网络请求</strong>。</p><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>这个生命周期函数会在组件卸载以及销毁之前调用。</p><p><strong>使用场景：</strong></p><p>通常用来执行组件的<strong>清理操作</strong>，例如：清除 timer、取消网络请求、清除订阅等。</p><h2 id="为什么废弃三个生命周期函数"><a href="#为什么废弃三个生命周期函数" class="headerlink" title="为什么废弃三个生命周期函数"></a>为什么废弃三个生命周期函数</h2><p>React 在 16.3 版本中：</p><ul><li>  将 componentWillMount、componentWillReceiveProps、componentWillUpdate 三个生命周期钩子加上了 UNSAFE 前缀，变为 UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate。</li><li>  并引入了一个新的生命周期钩子：getDerivedStateFromProps。</li></ul><p>并在 17.0 以及之后的版本中：</p><ul><li>  删除了 componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子。</li><li>  不过 UNSAFE_componentWillMount、UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate 还是可以用的。</li></ul><p><strong>为什么</strong>要废弃这三个生命周期钩子？它们有哪些问题呢？React 又是<strong>如何解决</strong>的呢？</p><p>我们知道 React 的更新流程分为：render 阶段和 commit 阶段。componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子都是在 render 阶段执行的。</p><p>在 fiber 架构被应用之前，render 阶段是不能被打断的。当页面逐渐复杂之后，就有可能会阻塞页面的渲染，于是 React 推出了 fiber 架构。在应用 fiber 架构之后，低优先级任务的 render 阶段可以被高优先级任务打断。</p><p>而这导致的<strong>问题</strong>就是：<strong>在 render 阶段执行的生命周期函数可能被执行多次</strong>。像 componentWillMount、componentWillReceiveProps、componentWillUpdate 这三个生命周期钩子，如果我们在其中执行一些具有副作用的操作，例如发送网络请求，就有可能导致一个同样的网络请求被执行多次，这显然不是我们想看到的。</p><p>而 React 又没法强迫开发者不去这样做，因为怎么样使用 React 是开发者的自由，所以 React 就新增了一个静态的生命周期 getDerivedStateFromProps，来解决这个问题。</p><p>用一个<strong>静态函数</strong> getDerivedStateFromProps 来取代被废弃的几个生命周期函数，这样开发者就无法通过 this 获取到组件的实例，也不能<strong>发送网络请求</strong>以及<strong>调用</strong> <code>this.setState</code>。它就是强制开发者在 render 之前只做无副作用的操作，间接强制我们无法进行这些不合理不规范的操作，从而避免对生命周期的滥用。</p><h2 id="父子组件生命周期函数调用顺序"><a href="#父子组件生命周期函数调用顺序" class="headerlink" title="父子组件生命周期函数调用顺序"></a>父子组件生命周期函数调用顺序</h2><p>接下来我们来探究一下 React 中父子组件生命周期函数的执行顺序。由不同的原因导致的组件渲染，React 会执行不同的生命周期函数。例如：在首次渲染的时候，会执行与 mount 相关的生命周期函数；触发子组件的 <code>this.setState</code> 只会调用子组件中与 update 相关的生命周期函数；触发父组件的 <code>this.setState</code> 则会调用父子组件中与 update 相关的生命周期函数等。</p><p>为了探究父子组件以及不同子组件之间生命周期函数的执行顺序，我初始化了三个组件分别是父组件 AppApp、子组件 Child1Child1、子组件 Child2Child2。它们的结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307ff86d82ce4d8eaab1a436234aeada~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><h2 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h2><p>在首次渲染中，我们探究图中 Mount 阶段生命周期钩子的执行顺序。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a0d0ce7762a43b2935328e387d483e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p><em>注：红色为 React 17 已经废弃的生命周期钩子，绿色为新增的生命周期钩子</em></p><p>因为<strong>被废弃</strong>的生命周期钩子和<strong>新增</strong>的生命周期钩子不能同时出现在代码中，所以我们分情况进行：</p><h3 id="旧的生命周期函数调用顺序"><a href="#旧的生命周期函数调用顺序" class="headerlink" title="旧的生命周期函数调用顺序"></a>旧的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillMount() &#123;</span><br><span class="line">    console.log(&#39;App componentWillMount&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#39;App componentDidMount&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillMount() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentWillMount&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidMount&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941d9f63ea874c198ead8a02b7a9490f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>其中 constructor、componentWillMount、render 为 <code>render</code> 阶段执行的生命周期函数，componentDidMount 为 <code>commit</code> 阶段执行的生命周期函数。</p><ul><li>  首先<strong>依次</strong>执行父组件 render 阶段的生命周期函数；</li><li>  然后<strong>依次</strong>执行子组件 render 阶段的生命周期函数；</li><li>  最后<strong>交叉</strong>执行子组件和父组件 commit 阶段的生命周期函数。</li></ul><p>React Fiber 树的构建、更新类似于树的先序遍历（深度优先搜索）。在“递归”时，执行 render 阶段的生命周期函数；在“回溯”时，执行 commit 阶段的生命周期函数。</p><p>对于 render 阶段的生命周期函数，其顺序是 <code>父组件</code> -&gt; <code>子组件</code>；而对于 commit 阶段的生命周期函数，其顺序是 <code>子组件</code> -&gt; <code>父组件</code>。</p><p>需要<strong>注意</strong>的是：这里的执行顺序并不是真正的树的先序遍历。在“回溯”时，是交叉执行各子组件和父组件 commit 阶段的生命周期函数。</p><h3 id="新的生命周期函数调用顺序"><a href="#新的生命周期函数调用顺序" class="headerlink" title="新的生命周期函数调用顺序"></a>新的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps() &#123;</span><br><span class="line">    console.log(&#39;App static getDerivedStateFromProps&#39;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#39;App componentDidMount&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(props) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;props.order&#125; static getDerivedStateFromProps&#96;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidMount&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10eb1d78b6164549895a14a34eb82007~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>可以看到，在首次渲染时，getDerivedStateFromProps 的执行顺序基本上替代了 componentWillMount 的执行顺序。</p><p>但是需要<strong>注意</strong>：getDerivedStateFromProps 是一个<strong>静态方法</strong>，不能通过 this 获取到组件实例，如果我们要拿到组件的 props 和 state，必须要通过参数才能拿到。而在 componentWillMount 中，则是通过 this.props 拿到 props。</p><h2 id="子组件状态改变"><a href="#子组件状态改变" class="headerlink" title="子组件状态改变"></a>子组件状态改变</h2><p>接下来，我们分别为父组件和子组件加上 onClick 事件，当点击子组件对应的文字时，让子组件更新，调用其 <code>this.setState</code> 方法，再来看看各生命周期的执行顺序。</p><h3 id="旧的生命周期函数调用顺序-1"><a href="#旧的生命周期函数调用顺序-1" class="headerlink" title="旧的生命周期函数调用顺序"></a>旧的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillReceiveProps() &#123;</span><br><span class="line">    console.log(&#39;App componentWillReceiveProps&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentWillUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#39;App shouldComponentUpdate&#39;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentDidUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;App&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; componentWillReceiveProps&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentWillUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidMount&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; shouldComponentUpdate&#96;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当点击文字 Child1 时，其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7602bb3b70d473b9b19a46185ff930c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>当点击文字 Child2 时，其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbdd4ddabd2f434293da63afdc81907e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>上面的结果中，<strong>并没有</strong>执行 componentWillReceiveProps 生命周期函数，因为使用 <code>this.setState</code> 触发组件更新时，并不会调用此生命周期钩子，只有 <strong>props 改变</strong>或者<strong>父组件更新导致子组件重新渲染</strong>时，才会执行这个生命周期钩子，看它的名字也知道它仅和 props 有关。</p><ul><li>  由于组件的 state 改变导致组件更新<strong>不会执行</strong> <code>componentWillReceiveProps</code>；</li><li>  执行 <code>shouldComponent</code> 判断组件是否需要更新，需要则执行后续生命周期函数，否则不执行后续生命周期函数；</li><li>  在渲染之前，执行 <code>componentWillUpdate</code>；</li><li>  执行渲染方法 <code>render</code>；</li><li>  将更改提交至 DOM 树之后，执行 <code>componentDidUpdate</code>；</li></ul><p><strong>注意</strong>：这里没有使用 getSnapshotBeforeUpdate 这个新增的生命周期函数，因为新增的生命周期函数与被废弃的生命周期函数同时写入代码中，React 会报错。</p><h3 id="新的生命周期函数调用顺序-1"><a href="#新的生命周期函数调用顺序-1" class="headerlink" title="新的生命周期函数调用顺序"></a>新的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps() &#123;</span><br><span class="line">    console.log(&#39;App static getDerivedStateFromProps&#39;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#39;App shouldComponentUpdate&#39;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps) &#123;</span><br><span class="line">    console.log(&#39;App getSnapshotBeforeUpdate&#39;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentDidUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;App&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(props) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;props.order&#125; static getDerivedStateFromProps&#96;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; shouldComponentUpdate&#96;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;prevProps.order&#125; getSnapshotBeforeUpdate&#96;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当点击文字 Child1 时，其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0b3aef3e03441dadec446e01efcf4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>当点击文字 Child2 时，其执行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5683a7e8df9b4b3794dc5c02ad5fa98b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>可以看到，子组件的状态发生改变，只会执行该子组件对应的生命周期函数，而不会执行其父组件或其兄弟组件的生命周期函数。</p><ul><li>  首先执行 <code>getDerivedStateFromProps</code>，在这里可以根据 props 更新 state；</li><li>  然后判断该组件是否需要更新，即执行 <code>shouldComponentUpdate</code>；</li><li>  需要更新则执行 <code>render</code> 函数以及后续生命周期函数，否则跳过后面生命周期函数的执行；</li><li>  在将更改提交至 DOM 树之前执行 <code>getSnapshotBeforeUpdate</code>，在这里可以获取 DOM 被更改前的最后一次快照；</li><li>  最后在将更改提交至 DOM 树之后执行 <code>componentDidUpdate</code>。</li></ul><h2 id="父组件状态改变"><a href="#父组件状态改变" class="headerlink" title="父组件状态改变"></a>父组件状态改变</h2><p>知道了子组件更新时，生命周期函数的执行顺序。我们点击父组件中对应文字，让其调用父组件的 <code>this.setState</code> 方法，触发父组件和子组件的重新渲染，看看父子组件生命周期函数的执行顺序。</p><h3 id="旧的生命周期函数调用顺序-2"><a href="#旧的生命周期函数调用顺序-2" class="headerlink" title="旧的生命周期函数调用顺序"></a>旧的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillReceiveProps() &#123;</span><br><span class="line">    console.log(&#39;App componentWillReceiveProps&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentWillUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#39;App shouldComponentUpdate&#39;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentDidUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;App&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; componentWillReceiveProps&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  UNSAFE_componentWillUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentWillUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; shouldComponentUpdate&#96;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>父子组件生命周期函数调用顺序为：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa1ecb76a0a498c95efb60454db338c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>我们知道 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 这四个生命周期函数是在 <strong>render 阶段</strong>调用的，而 componentDidUpdate 生命周期函数是在 <strong>commit 阶段</strong>调用的。</p><p>它们的执行顺序和<strong>首次渲染</strong>中得到的结论一样，还是满足如下特点：</p><ul><li>  首先<strong>依次</strong>执行父组件 render 阶段的生命周期函数；</li><li>  然后<strong>依次</strong>执行子组件 render 阶段的生命周期函数；</li><li>  最后<strong>交叉</strong>执行子组件和父组件 commit 阶段的生命周期函数。</li></ul><p>因为是在父组件中调用 <code>this.setState</code> 方法触发的更新，并<strong>不会执行</strong>它的 componentWillReceiveProps 生命周期函数，而由于父组件更新导致的子组件更新，是<strong>会执行</strong>子组件的 componentWillReceiveProps 生命周期函数的，这点也在<strong>子组件状态改变</strong>中提到了。</p><h3 id="新的生命周期函数调用顺序-2"><a href="#新的生命周期函数调用顺序-2" class="headerlink" title="新的生命周期函数调用顺序"></a>新的生命周期函数调用顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#39;App constructor&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps() &#123;</span><br><span class="line">    console.log(&#39;App static getDerivedStateFromProps&#39;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#39;App shouldComponentUpdate&#39;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps) &#123;</span><br><span class="line">    console.log(&#39;App getSnapshotBeforeUpdate&#39;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#39;App componentDidUpdate&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#39;App render&#39;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;App&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;1&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Child order&#x3D;&#123;2&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; constructor&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(props) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;props.order&#125; static getDerivedStateFromProps&#96;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;nextProps.order&#125; shouldComponentUpdate&#96;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps) &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;prevProps.order&#125; getSnapshotBeforeUpdate&#96;);</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; componentDidUpdate&#96;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&#96;Child$&#123;this.props.order&#125; render&#96;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;() &#x3D;&gt; this.setState((count) &#x3D;&gt; (&#123; count: count + 1 &#125;))&#125;&gt;</span><br><span class="line">        Child&#123;this.props.order&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>父子组件生命周期函数调用顺序为：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/020ee9c7690e4c70a1311ea694fbc992~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"></p><p>可以看到，换成 getDerivedStateFromProps 后，不管是不是通过调用 <code>this.setState</code> 导致的组件更新，都会执行 getDerivedStateFromProps 生命周期函数。</p><p>这里还是符合前面说的规律：</p><ul><li>  首先<strong>依次</strong>执行父组件 render 阶段的生命周期函数；</li><li>  然后<strong>依次</strong>执行子组件 render 阶段的生命周期函数；</li><li>  最后<strong>交叉</strong>执行子组件和父组件 commit 阶段的生命周期函数。</li></ul><h2 id="关于其执行顺序原因的理解"><a href="#关于其执行顺序原因的理解" class="headerlink" title="关于其执行顺序原因的理解"></a>关于其执行顺序原因的理解</h2><p><strong>为什么在 commit 阶段要先执行父组件的 getSnapshotBeforeUpdate，再执行子组件的 componentDidUpdate？而在 render 阶段却是先执行父组件的 render，再执行子组件的 constructor 呢？</strong></p><p>因为 getSnapshotBeforeUpdate 是为了获取 DOM 更新前的一次快照，而 componentDidUpdate 是在 DOM 更新之后执行的。自然要在 DOM 更新之前才能获取每一个组件的 DOM 快照，在 DOM 更新之后才能调用 componentDidUpdate。</p><p>如果已经调用了 componentDidUpdate，说明 DOM 已经更新完了，此时再调用 getSnapshotBeforeUpdate 还能获取 DOM 更新前的快照吗？显然不行！</p><p>至于先执行父组件的 render 再执行子组件的 constructor 是因为：先执行父组件的 render 函数之后，才知道父组件有哪些子组件，接着才能调用对应子组件的 constructor 去构造子组件。这一切都是如此的合理！</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件通讯</title>
      <link href="2022/04/04/react-zu-jian-tong-xun/"/>
      <url>2022/04/04/react-zu-jian-tong-xun/</url>
      
        <content type="html"><![CDATA[<h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><h3 id="1-组件通讯-概念"><a href="#1-组件通讯-概念" class="headerlink" title="1. 组件通讯-概念"></a>1. 组件通讯-概念</h3><p>了解组件通讯的意义<br>大致步骤：</p><ul><li>知道组件的特点</li><li>知道组件通讯意义</li></ul><p>具体内容：</p><ol><li>组件的特点<ul><li>组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据</li><li>在组件化过程中，通常会将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能</li></ul></li><li>知道组件通讯意义<ul><li>而在这个过程中，多个组件之间不可避免的要共享某些数据</li><li>为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通</li><li>这个过程就是<strong>组件通讯</strong></li></ul></li></ol><p><strong>总结：</strong></p><ul><li><p>组件状态是独立的，组件化之后涉及状态同步，需要进行组件通讯</p><h3 id="2-组件通讯-props-基本使用"><a href="#2-组件通讯-props-基本使用" class="headerlink" title="2. 组件通讯-props 基本使用"></a>2. 组件通讯-props 基本使用</h3><p>能够通过 props 传递数据和接收数据<br>大致步骤：</p></li><li><p>传递数据和接收数据的过程</p></li><li><p>函数组件使用 props</p></li><li><p>类组件使用 props</p></li></ul><p>具体内容：</p><ol><li>传递数据和接收数据的过程<ul><li>使用组件的时候通过属性绑定数据，在组件内部通过 props 获取即可。</li></ul></li><li>函数组件使用 props<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Hello name=<span class="string">&quot;jack&quot;</span> age=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 定义组件 props包含&#123;name:&#x27;jack&#x27;,age:&#x27;20&#x27;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到数据:&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 类组件使用 props</span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line">&lt;Hello name=<span class="string">&quot;jack&quot;</span> age=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line"><span class="comment">// 定义组件 props包含&#123;name:&#x27;jack&#x27;,age:&#x27;20&#x27;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到的数据:&#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li><p>props 是实现组件通讯的关键，它通过使用组件绑定属性，组件内部使用 props 来传值。</p><h3 id="3-组件通讯-props-注意事项"><a href="#3-组件通讯-props-注意事项" class="headerlink" title="3. 组件通讯-props 注意事项"></a>3. 组件通讯-props 注意事项</h3><p>知道 props 是单项数据流只读，但是可以传递任意数据。<br>大致步骤：</p></li><li><p>知道什么是单向数据流</p></li><li><p>知道 props 可以传递什么数据</p></li></ul><p>具体内容：</p><ol><li>知道什么是单向数据流？<ul><li>单向数据流，是从上到下的，自顶而下的，数据流。</li><li>好比：河流，瀑布，只能从上往下流动，上游污染下游受影响，但是下游不能影响上游。</li><li>父组件传递数据给子组件，父组件更新数据子组件自动接收更新后数据，当是子组件是不能修改数据的。</li></ul></li><li>props 可以传递什么数据？任意<ul><li>字符串</li><li>数字</li><li>布尔</li><li>数组</li><li>对象</li><li>函数</li><li>JSX （插槽）</li></ul></li></ol><p><strong>总结：</strong></p><ul><li><p>props 传递数据是单向的，可以传递任意格式的数据。</p><h3 id="4-组件通讯-父传子方式"><a href="#4-组件通讯-父传子方式" class="headerlink" title="4. 组件通讯-父传子方式"></a>4. 组件通讯-父传子方式</h3><p>通过 props 将父组件的数据传递给子组件<br>大致步骤：</p></li><li><p>父组件提供要传递的 state 数据</p></li><li><p>给子组件标签添加属性，值为 state 中的数据</p></li><li><p>子组件中通过 props 接收父组件中传递的数据</p></li></ul><p>具体代码：</p><ol><li>父组件提供要传递的 state 数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="built_in">this</span>.state.money&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 给子组件标签添加属性，值为 state 中的数据</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;<span class="built_in">this</span>.state.money&#125;&lt;/h1&gt;</span><br><span class="line">+        <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">money</span>=<span class="string">&#123;this.state.money&#125;</span> /&gt;</span></span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 子组件中通过 props 接收父组件中传递的数据</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li>父组件声明state,在子组件标签通过属性绑定，在子组件中通过props使用。<h3 id="5-组件通讯-父传子练习"><a href="#5-组件通讯-父传子练习" class="headerlink" title="5. 组件通讯-父传子练习"></a>5. 组件通讯-父传子练习</h3>通过提供的素材，利用父传子知识，完成以下练习<br>界面参考：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1649054833475-9cc4fd44-702b-4482-8fa7-961eb2a6d088.png#clientId=ue51438c4-ae5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u65291cc6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=973&originalType=url&ratio=1&rotation=0&showTitle=false&size=25468&status=done&style=none&taskId=u93fa6c90-e7d6-432c-ae32-f18f7892d4a&title=" alt="image.png"><br>配套素材：</li></ul><ol><li>jsx 结构<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">  &lt;h1&gt;今日要闻&lt;/h1&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;坚定不移走中国特色社会主义法治道路&lt;/h3&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;detail&quot;</span>&gt;</span><br><span class="line">      &lt;span&gt;新华社&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;<span class="number">774</span>点赞&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;<span class="number">2021</span>年度法治人物——倪伯苍 &lt;/h3&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;detail&quot;</span>&gt;</span><br><span class="line">      &lt;span&gt;央视网&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;<span class="number">774</span>点赞&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;岁末年终 愿这份“温良”伴你乘风破浪 &lt;/h3&gt;</span><br><span class="line">    &lt;div className=<span class="string">&quot;detail&quot;</span>&gt;</span><br><span class="line">      &lt;span&gt;央视新闻客户端&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;<span class="number">248</span>点赞&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>组件样式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line">.parent h1 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: 20px <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">  width: <span class="number">100</span>%;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.child h3 &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">  color: #333;</span><br><span class="line">  margin: <span class="number">0</span>;</span><br><span class="line">  padding: 10px <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.child .detail &#123;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  color: #999;</span><br><span class="line">&#125;</span><br><span class="line">.child .detail span &#123;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现思路<ol><li>新建样式 src/index.css 准备样式，导入到入口文件</li><li>新建 Parent 组件，渲染准备的 parent 的结构，导入到入口文件渲染该组件</li><li>新建 Child 组件，渲染准备的渲染 child 的结构，导入到 Parent 组件使用</li><li>Parent 组件，参考界面定义状态，通过状态遍历 Child 组件传值，Child 组件根据 props 渲染。<h3 id="6-组件通讯-子传父方式"><a href="#6-组件通讯-子传父方式" class="headerlink" title="6. 组件通讯-子传父方式"></a>6. 组件通讯-子传父方式</h3>通过 props 将子组件的数据传递给父组件<br>大致步骤：</li></ol></li></ol><ul><li>父组件提供回调函数，通过 props 传递给子组件</li><li>子组件调用 props 中的回调函数，函数可传参</li><li>父组件函数的参数就是子组件传递的数据</li></ul><p>具体代码：</p><ol><li>父组件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  buyPhone = <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      money: <span class="built_in">this</span>.state.money - price,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; money &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;父组件：&#123;money&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;Child money=&#123;money&#125; buyPhone=&#123;<span class="built_in">this</span>.buyPhone&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>子组件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Child = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 子组件调用父组件传递过来的回调函数</span></span><br><span class="line">    props.buyPhone(<span class="number">5000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;子组件：&#123;props.money&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;买手机&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li>子组件如何传递数据给父组件？触发父组件传递的回调函数传入数据</li><li>父组件如何接收子组件的数据？回调函数的参数是子组件传递的数据</li><li>父组件数据更新后，传递给子组件的数据是否更新？自动更新<h3 id="7-组件通讯-子传父练习"><a href="#7-组件通讯-子传父练习" class="headerlink" title="7. 组件通讯-子传父练习"></a>7. 组件通讯-子传父练习</h3>通过提供的素材，利用子传父知识，完成点赞功能<br>界面参考：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1649054833490-426c262b-7ac9-4150-bd0c-b1d271bb658a.png#clientId=ue51438c4-ae5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u24a90168&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=951&originalType=url&ratio=1&rotation=0&showTitle=false&size=23841&status=done&style=none&taskId=u4687b66a-907a-4b87-9f35-4e94dd98fc9&title=" alt="image.png"><br>配套素材：</li></ul><ol><li>jsx 结构<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line">  &lt;h3&gt;坚定不移走中国特色社会主义法治道路&lt;/h3&gt;</span><br><span class="line">  &lt;div className=<span class="string">&quot;detail&quot;</span>&gt;</span><br><span class="line">    &lt;span&gt;新华社&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">774</span>点赞&lt;/span&gt;</span><br><span class="line">+    <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>点赞+1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li>新增样式<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.child .detail span:last-child &#123;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  color: burlywood;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现思路<ol><li>子组件绑定点击事件指定处理函数</li><li>在处理函数中调用父组件传递的回调函数</li><li>给回调函数传入评论 ID 和点赞后的数量</li><li>父组件在回调函数中更新数据<h3 id="8-组件通讯-兄弟组件通讯"><a href="#8-组件通讯-兄弟组件通讯" class="headerlink" title="8. 组件通讯-兄弟组件通讯"></a>8. 组件通讯-兄弟组件通讯</h3>通过状态提升思想完成兄弟组件数据通讯<br>大致步骤：</li></ol></li></ol><ul><li>状态提升思想是什么？</li><li>演示通过状态提升完成兄弟组件通讯。</li></ul><p>具体内容：</p><ol><li>状态提升思想是什么？<ul><li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态和修改状态的方法</li><li>需要通讯的组件通过 props 接收状态和函数即可<img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1649054833521-966e46b1-c275-4120-9c42-926cb5485916.png#clientId=ue51438c4-ae5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u09829cb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=456&originWidth=902&originalType=url&ratio=1&rotation=0&showTitle=false&size=35771&status=done&style=none&taskId=u229e71f1-6872-4999-9021-b1d80f12244&title=" alt="image.png"></li></ul></li><li>参考代码index.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 导入两个子组件</span></span><br><span class="line"><span class="keyword">import</span> Jack <span class="keyword">from</span> <span class="string">&#x27;./Jack&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Rose <span class="keyword">from</span> <span class="string">&#x27;./Rose&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// App 是父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 状态提升到父组件</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  changeMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; msg &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是App组件&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="comment">/* 兄弟组件 1 */</span>&#125;</span><br><span class="line">        &lt;Jack changeMsg=&#123;<span class="built_in">this</span>.changeMsg&#125;&gt;&lt;/Jack&gt;</span><br><span class="line">        &#123;<span class="comment">/* 兄弟组件 2 */</span>&#125;</span><br><span class="line">        &lt;Rose msg=&#123;<span class="built_in">this</span>.state.msg&#125;&gt;&lt;/Rose&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">Jack.js</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Jack</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  say = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改数据</span></span><br><span class="line">    <span class="built_in">this</span>.props.changeMsg(<span class="string">&#x27;you jump i look&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Jack组件&lt;/h3&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.say&#125;&gt;说&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Rose.jsx</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Rose</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;我是Rose组件-&#123;<span class="built_in">this</span>.props.msg&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-组件通讯-context-跨级组件通讯"><a href="#9-组件通讯-context-跨级组件通讯" class="headerlink" title="9. 组件通讯-context 跨级组件通讯"></a>9. 组件通讯-context 跨级组件通讯</h3>掌握使用 context 实现跨级组件通讯<br>大致步骤：</li></ol><ul><li>什么是跨级组件通讯？</li><li>context 怎么去理解？</li><li>演示使用 context 完成跨级组件通讯。</li></ul><p>具体内容：</p><ol><li>什么是跨级组件通讯？<ul><li>组件间相隔多层，理解成叔侄，甚至更远的亲戚。</li></ul></li><li>context 怎么去理解<ul><li>术语：上下文</li><li>理解：一个范围，只要在这个范围内，就可以跨级组件通讯。（不需要 props 层层传递）</li></ul></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1649054834386-52b403c4-fd4d-4058-8335-0407b7087ad1.png#clientId=ue51438c4-ae5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5bb160af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=1685&originalType=url&ratio=1&rotation=0&showTitle=false&size=163605&status=done&style=none&taskId=u05165b39-e7cd-4e6b-b191-085f60987a0&title=" alt="image.png"></p><ol><li>演示使用 context 完成跨级组件通讯</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1649055000820-48e567e5-606a-41fd-83c3-1c3139072b55.png#clientId=ue51438c4-ae5e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=u392c688c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=1171&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13444&status=done&style=none&taskId=ua1e101a4-7735-4c74-98c4-ad34661f170&title=&width=851.6363636363636" alt="image.png">index.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Parent <span class="keyword">from</span> <span class="string">&#x27;./Parent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建上下文对象</span></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    money: <span class="number">10000</span></span><br><span class="line">  &#125;</span><br><span class="line">  updateMoney = <span class="function"><span class="params">newMoney</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      money: newMoney</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 2. Provider包裹确定上下文生效范围，value注入范围内可用的数据</span></span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;</span><br><span class="line">        money: <span class="built_in">this</span>.state.money,</span><br><span class="line">        updateMoney: <span class="built_in">this</span>.updateMoney</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">          &lt;h1&gt;根组件：&#123;<span class="built_in">this</span>.state.money&#125;&lt;/h1&gt;</span><br><span class="line">          &lt;hr /&gt;</span><br><span class="line">          &lt;Parent /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/MyContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parent.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">&#x27;./Child&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">      &lt;h3&gt;父组件：&lt;/h3&gt;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parent;</span><br></pre></td></tr></table></figure><p>Child.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MyContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 3. 通过Consumer来消费数据，value=&gt;&#123; 这里使用数据 &#125;</span></span><br><span class="line">    &lt;MyContext.Consumer&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">value</span>) =&gt;</span> (</span><br><span class="line">        &lt;div className=<span class="string">&quot;child&quot;</span>&gt;</span><br><span class="line">          &lt;h5&gt;子组件：&#123;value.money&#125; &lt;button onClick=&#123;<span class="function">()=&gt;</span>value.updateMoney(<span class="number">5000</span>)&#125;&gt;修改money&lt;<span class="regexp">/button&gt;&lt;/</span>h5&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/MyContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>使用creatContext()创建一个上下文对象，包含：Provider Consumer 组件。</li><li>使用 Provider 包裹组件，value 属性注入状态，函数，被包裹组件下的任何组件可以使用。</li><li>使用 Consumer 消费 Provider 提供的数据和函数，语法{value=&gt;使用数据和函数}</li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022前端行业的趋势总结</title>
      <link href="2022/04/03/2022-qian-duan-xing-ye-de-qu-shi-zong-jie/"/>
      <url>2022/04/03/2022-qian-duan-xing-ye-de-qu-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<ol><li>基础框架/工程化</li><li>语言</li><li>行业趋势</li><li>底层演进<h1 id="1-基础框架-工程化"><a href="#1-基础框架-工程化" class="headerlink" title="1. 基础框架/工程化"></a>1. 基础框架/工程化</h1><h2 id="MV-框架"><a href="#MV-框架" class="headerlink" title="MV*框架"></a>MV*框架</h2></li></ol><ul><li><p>React（Next.js）</p></li><li><p>Vue（nuxt.js）</p></li><li><p>Svelte</p></li><li><p>Angular</p><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2></li><li><p>传统：Webpack，Rollup，Parcel，Esbuild</p></li><li><p>ESM相关：Snowpack，Vite</p><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2></li><li><p>Babel</p></li><li><p>Prettier</p></li><li><p>ESLint</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2></li><li><p>Tailwind CSS（原子类）</p><h2 id="WEB3D"><a href="#WEB3D" class="headerlink" title="WEB3D"></a>WEB3D</h2></li><li><p>Three.js</p></li><li><p>Oasis Engine</p><h2 id="跨端"><a href="#跨端" class="headerlink" title="跨端"></a>跨端</h2></li><li><p>React Native</p></li><li><p>Flutter</p></li><li><p>Weex</p></li><li><p>uni-app</p></li><li><p>taro</p><h2 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h2></li><li><p>Tauri（Webview+Rust/.Net/Go）</p></li><li><p>electron（Chromium+Nodejs）</p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2></li><li><p>qiankun</p></li><li><p>single-spa</p></li><li><p>micro-app</p><h2 id="E2E测试"><a href="#E2E测试" class="headerlink" title="E2E测试"></a>E2E测试</h2></li><li><p>cypress（node服务，与程序一起运行）</p></li><li><p>puppeteer（无头浏览器）</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2></li><li><p>zx</p><h1 id="2-语言"><a href="#2-语言" class="headerlink" title="2. 语言"></a>2. 语言</h1><p>前端如果学习其他语言，有以下推荐：</p></li><li><p>Rust是js基础设施的未来-Lee Robinson</p></li><li><p>全栈——go</p></li><li><p>AI——Python</p></li><li><p>Flutter——Dart</p><h1 id="3-大前端（泛前端）"><a href="#3-大前端（泛前端）" class="headerlink" title="3. 大前端（泛前端）"></a>3. 大前端（泛前端）</h1><p>写 HTML 模板的“石器时代”，到前后端分离、大前端的“工业时代”，再到现在跨端技术、低代码的“电气时代”。前端研发的职责一直在改变，同时前端研发需要掌握的技术也在迭代更新。</p></li></ul><p><strong>全栈</strong><br>一个“全栈开发者”可能会使用以下技能点：<br>前端：JavaScript、H5、CSS3、sass、less、React、Vue、webpack、jest。<br>后端：Nodejs/Deno、Go、Java、Spring、Gin、Kafka、Hadoop。<br>数据库：MySQL、mongoDB、redis、clickhouse。<br>运维：网络协议、CDN、Nginx、ZooKeeper、Docker、Kubernetes。</p><h1 id="4-底层演变"><a href="#4-底层演变" class="headerlink" title="4.底层演变"></a>4.底层演变</h1><p><strong>2021 JavaScript大事件 ↓</strong><br><strong>「JavaScript」</strong><br>8.24：TypeScript 新官网上线<br>12.4：JavaScript 26 岁了<br><strong>「Node.js」</strong><br>2.2：npm 7.0 正式可用<br>3.29：Deno 公司成立<br>4.21：Node.js 16 发布<br>7.20：Node-RED 2.0 发布，低代码编程工具<br>9.20：Node.js 发布 Corepack，用于管理npm、yarn、pnpm、cnpm<br>10.19：Node.js 17 发布<br><strong>「Vue」</strong><br>8.3：Vue.js 被选作维基百科的前端框架<br>8.5：Vue 3.2 发布<br>11.24：Pinia 正式成为 vuejs 的一员<br><strong>「React」</strong><br>5.28：React 18 alpha 发布<br>10.5：React 全新文档发布<br>11.27：Next.js 12 发布<br>12.14：Create React App 5.0 发布<br><strong>「打包工具」</strong><br>2021.1.6 Snowpack 3.0 发布<br>2021.2.17 Vite 2.0 发布<br>2021.10.13 Parcel v2 发布<br><strong>「其他」</strong><br>2021.3.6 jQuery 3.6.0 发布<br>2021.3.17 Chrome V8 9.0 发布<br>2021.10.7 jQuery Mobile 弃用<br>2021.11.4 Angular v13 发布</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件机制</title>
      <link href="2022/04/01/shi-jian-ji-zhi/"/>
      <url>2022/04/01/shi-jian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="答题大纲"><a href="#答题大纲" class="headerlink" title="答题大纲"></a>答题大纲</h1><ol><li>基本知识点，宏任务，微任务有哪些</li><li>说是事件机制过程，边说边画</li><li>说async/await执行顺序，可以把chrome的优化，做法其实违反了规范的</li><li>把node的事件循环也说一下，重复1，2，3点，node的第3点说的是node11前后的事件循环变动点。<h1 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h1>javaScript代码在执行的过程中，除了依靠函数调用栈来搞定的执行顺序外，还依靠任务队列（task queue）来搞定另外一些代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为macro-task（宏任务）与micro-task（微任务）。<br>macro-task（宏任务）大概包括：</li></ol><ul><li>script（整体代码）</li><li>setTimeout</li><li>setInterval</li><li>setimmediate</li><li>U/O</li><li>UI render</li></ul><p>micro-task（微任务）大概包括：</p><ul><li>process.nextTick</li><li>Promise</li><li>Async/Await(实际就是Promise)</li><li>MutationObserver(HTML5新特性)</li></ul><p>执行流程图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1646460690809-20e98221-db94-4db4-a7db-553c5e2b97f9.png#clientId=ued8042fa-e2de-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7a4e6686&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uade40599-ee78-47e5-b116-57305a3987c&title="><br><strong>总结</strong>：<br>执行宏任务，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务进行下一轮循环。<br>举个例子：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1646460896414-70c65d84-2be8-44e9-a380-86c3a6fb656d.png#clientId=ued8042fa-e2de-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u7b664c1a&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1000&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u09ed14d5-99d5-416f-9802-fb1bffe630b&title="><br>结合历程图该例子执行顺序：async2 end =&gt; Promise =&gt; async1 end =&gt; promise1 =&gt; promis2 =&gt; setTimeout，但是对于async/await，我们有个细节还要处理一下。</p><h1 id="async-await执行顺序"><a href="#async-await执行顺序" class="headerlink" title="async/await执行顺序"></a>async/await执行顺序</h1><p>我们知道async隐式返回Promise作为结果的函数，那么我们可以简单理解为，await后面的函数执行完毕时，await会产生一个微任务（Promise.then是微任务）。但是我们要注意这个微任务产生的时机，他是执行完await之后，直接跳出async函数，执行其他代码（此处就是协程的运作，A暂停，控制权交给B）。其他代码执行完毕后，再回到async函数执行剩下的代码，然后把await后面的代码注册到微任务队列中。<br>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">await</span> async2()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;async2 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">resolve()</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动</span></span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><p>分析这一段代码：</p><ul><li><p>执行代码，输出script start</p></li><li><p>执行async1()，会调用async2()，然后输出async2 end，此时将会保留async1函数的上下文，然后跳出async1函数。</p></li><li><p>遇到setTimeout，产生一个宏任务。</p></li><li><p>执行Promise，输出Promise。遇到then，产生一个微任务。</p></li><li><p>继续执行代码，输出script end。</p></li><li><p>代码逻辑执行完毕（当前宏任务执行完毕），开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务。</p></li><li><p>执行产生的微任务，输出promise2，当前微任务队列执行完毕。执行权回到async1.</p></li><li><p>执行await，实际上会产生一个promise返回，即:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise_ = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve,reject)&#123;resolve(<span class="literal">undefined</span>)&#125;)</span><br></pre></td></tr></table></figure><p>执行完成，执行await后面的语句，输出async1 end</p></li><li><p>最后，执行下一个宏任务，即执行setTimeout，输出setTimeout</p></li></ul><p><strong>注意</strong>：新版的chrome浏览器中不是如上打印的，因为chrome优化了，await变得更快了，输出为：<br><code>script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; async1 end =&gt; promise1 =&gt;promise2 =&gt; setTimeout</code></p><h1 id="node中的事件循环"><a href="#node中的事件循环" class="headerlink" title="node中的事件循环"></a>node中的事件循环</h1><p>浏览器中有事件循环，node中也有，事件循环是node处理非阻塞I/O操作的机制，node中事件循环的实现是依靠的libuv引擎。由于node11之后，事件循环的一些原理发生了变化，这里就有以新的标准去讲，最后在列上变化让大家了解前因后果。</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>node中也有宏任务和微任务，与浏览器中的事件循环类似，其中，<br>macro-task（宏任务）大概包括：</p><ul><li>setTimeout</li><li>setInterval</li><li>setimmediate</li><li>script（整体代码）</li><li>I/O操作等</li></ul><p>micro-task（微任务）大概包括：</p><ul><li>process.nextTick（与普通微任务有区别，在微任务队列执行之前执行）</li><li>new Promise().then(回调)等。<h2 id="node事件循环整体理解"><a href="#node事件循环整体理解" class="headerlink" title="node事件循环整体理解"></a>node事件循环整体理解</h2><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1646567978751-d385bf58-f51e-4ece-93d5-3af96093dc16.png#clientId=u59de3cc2-ce21-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u23f0feef&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=751&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u66ae10b9-b89a-4bbf-9867-d3fc09e888d&title="><br>如图所示：<br>node循环阶段顺序为：<br>输入数据阶段（incoming data）-&gt; 轮询阶段（poll）-&gt; 检查阶段（check）-&gt; 关闭事件回调阶段（close callback）-&gt; 定时器检测阶段（times）-&gt; I/O事件回调阶段（I/O callbacks）-&gt; 闲置阶段（idle,prepare）-&gt;轮询阶段</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础</title>
      <link href="2022/04/01/qian-duan-ji-chu-1/"/>
      <url>2022/04/01/qian-duan-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前端基础"><a href="#一、前端基础" class="headerlink" title="一、前端基础"></a>一、前端基础</h1><h2 id="1-HTTP，HTML，浏览器"><a href="#1-HTTP，HTML，浏览器" class="headerlink" title="1.HTTP，HTML，浏览器"></a>1.HTTP，HTML，浏览器</h2><h3 id="1-1、说一下http和https"><a href="#1-1、说一下http和https" class="headerlink" title="1.1、说一下http和https"></a>1.1、说一下http和https</h3><p>https的SSL加密是在传输层实现的。<br>（1）http和https的基本概念<br>http：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是客户端和服务端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以是浏览器更加高效，使网络传输减少。</p><p>https：是以安全为目标的http通道，简单的说就是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>（2）http和https的区别？<br>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单的来说https协议是由http和SSl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要区别：</p><ul><li>https协议需要ca证书，费用较高。</li><li>http是超文本传输协议，信息是明文传输，https则具有安全性的ssl加密传输协议。</li><li>不同的链接方式，端口也不同，一般而言，http协议端口为80，https的端口为443。</li><li>http链接很简单，是无状态的；https协议是由SSL+http协议构成的可进行加密传输、身份认证的网洛协议，比http协议安全。</li></ul><p>（3）https协议的工作原理<br>客户端在使用https方式与Web服务器通信时有一下几个步骤。</p><ol><li>客户端使用https+url访问服务器，则需要web服务器建立ssl链接。</li><li>web服务器接受客户端的请求后，会将网站的证书（证书包含了公钥），返回或者传输给客户端。</li><li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方的协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，并传送给网站。</li><li>web服务器通过自己的私钥解密出会话秘钥。</li><li>web服务器通过会话秘钥加密与客户端之间的通信。</li></ol><p>（4）https协议的优点</p><ul><li>使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输构成中不被窃取、改变，确保数据的完整性。</li><li>https是先行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>比起同等http网站，采用https加密的网站在搜索结果中的排名将会更高。</li></ul><p>（5）https协议的缺点</p><ul><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%·20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能在同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ul><h3 id="1-2、tcp三次握手"><a href="#1-2、tcp三次握手" class="headerlink" title="1.2、tcp三次握手"></a>1.2、tcp三次握手</h3><p>客户端和服务端都需要直到各自可收发，因此需要三次握手。<br>简化三次握手：<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210413132536.png#align=left&display=inline&height=744&margin=%5Bobject%20Object%5D&originHeight=744&originWidth=623&status=done&style=none&width=623"><br>图片解析：C发起请求链接S确认，也发起链接C确认<br>每次握手的作用：<br>第一次握手：S只可以确认，自己可以接受C发送的报文段<br>第二次握手：C可以确认S收到了自己发送的报文段，并且可以确认自己可以接受S发送的报文端<br>第三次握手：S可以确认C收到了自己发送的报文段</p><h3 id="1-3、TCP和UDP的区别"><a href="#1-3、TCP和UDP的区别" class="headerlink" title="1.3、TCP和UDP的区别"></a>1.3、TCP和UDP的区别</h3><ol><li>TCP是面向链接的，UDP是无连接的即发送数据前不需要先建立链接。</li><li>TCP提供可靠的服务。也就是说，通过TCP链接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</li><li>TCP是面向字节流，UDP面向报文，并且网络出现拥塞不使得发送率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</li><li>TCP只能是1对1的，UDP支持1对1，1对多。</li><li>TCP的首部较大为20字节，而UDP只有8字节。</li><li>TCP是面向链接的可靠性传输，而UDP是不可靠的。</li></ol><h3 id="1-4、WebSocket的实现和应用"><a href="#1-4、WebSocket的实现和应用" class="headerlink" title="1.4、WebSocket的实现和应用"></a>1.4、WebSocket的实现和应用</h3><p>（1）什么是WebSocket？<br>WebSocket是HTML5中的协议，支持持久连续。http协议不支持持久性连接。HTTP1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的Keep-alive，将多个http请求合并为1个。<br>（2）WebSocket是什么样的协议，具体有什么优点？<br>HTTP的声明周期通过Request来界定，也就是Request一个Response，那么在HTTP1.0协议中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，是有一个connection：keep-alive，也就是说，在一个http连接中，可以发送多个Request，接受多个Response。但是，在http中一个Request只能对应一个Response，而且这个Response是被动的，不能主动发起。</p><p>WebSocket是基于HTTP协议的，或者说借用了HTTP协议完成了一部分握手，在握手阶段与http是相同的。<br>我们来看一个WebSocket协议的实现，基本是2个属性，upgrade，connection。<br>基本请求如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1、1</span><br><span class="line">Host: server. examp1e.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-webSocket-Protoco1: chat,superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http: //examp1e.com</span><br><span class="line">多了下面2个属性:</span><br><span class="line">Upgrade: webSocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">告诉服务器发送的是websocket</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">sec-WebSocket-Protoco1 : chat，superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><h3 id="1-5、HTTP请求的方式，HEAD方式"><a href="#1-5、HTTP请求的方式，HEAD方式" class="headerlink" title="1.5、HTTP请求的方式，HEAD方式"></a>1.5、HTTP请求的方式，HEAD方式</h3><p>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。<br>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</p><h3 id="1-6、一个图片url访问后直接下载怎样实现？"><a href="#1-6、一个图片url访问后直接下载怎样实现？" class="headerlink" title="1.6、一个图片url访问后直接下载怎样实现？"></a>1.6、一个图片url访问后直接下载怎样实现？</h3><p>请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为参数。<br>下载的情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、x-oss-object-type:</span><br><span class="line">Norma1</span><br><span class="line">2、x-oss-request-id:</span><br><span class="line">598D5ED34F29DO1FE2925F41</span><br><span class="line">3、x-oss-storage-c1ass:</span><br><span class="line">Standard</span><br></pre></td></tr></table></figure><h3 id="1-7、说一下web-Quality（无障碍）"><a href="#1-7、说一下web-Quality（无障碍）" class="headerlink" title="1.7、说一下web Quality（无障碍）"></a>1.7、说一下web Quality（无障碍）</h3><p>能够被残障人士使用的网站才能称得上一个易用（易访问的）网站。</p><p>例如：<br>使用alt属性：<br><code>&lt;img src=&quot;preson.jpg&quot; alt=&quot;this is person&quot; /&gt;</code><br>有时候浏览器会无法显示图像。<br>具体原因有：</p><ul><li>用户关闭图像显示</li><li>浏览器不支持图像显示的迷你浏览器</li><li>浏览器是语音浏览器（供盲人和弱视人群使用）</li></ul><p>使用alt属性，那么浏览器至少可以显示或读出有关图像的描述。</p><h3 id="1-8、几个实用的BOM属性对象方法"><a href="#1-8、几个实用的BOM属性对象方法" class="headerlink" title="1.8、几个实用的BOM属性对象方法?"></a>1.8、几个实用的BOM属性对象方法?</h3><p>什么是BOM？BOM是浏览器对象。<br>（1）location对象</p><ul><li>location.href–返回或设置当前文档的URL</li><li>location.search – 返回URL中的查询字符串部分。例如http: <a href="//www.dreamdu.com/dreamdu">//www.dreamdu.com/dreamdu</a>. php?id=5&amp;name=dreamdu返回包括(?)后面的内容?id=5&amp;name=dreamdu</li><li>location.hash –返回URL#后面的内容，如果没有#，返回空location.host –返回URL中的域名部分，例如 www. dreamdu.comlocation.hostname –返回URL中的主域名部分，例如 dreamdu.com</li><li>location.pathname –返回URL的域名后的部分。例如 <a href="http://www/">http://www</a>. dreamdu.com/xhtml/返回/xhtml/</li><li>location. port –返回URL中的端口部分。例如 <a href="http://www/">http://www</a>. dreamdu.com:8080/xhtml/返回8080</li><li>location.protocol – 返回URL中的协议部分。例如http: / / <a href="http://www.dreamdu.com:8080/xhtml/%E8%BF%94%E5%9B%9E(//)%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9http:location.assign">www.dreamdu.com:8080/xhtml/返回(//)前面的内容http:location.assign</a> –设置当前文档的URL</li><li>location.replace() –设置当前文档的URL，并且在history对象的地址列表中移除这个URL</li><li>location.replace(url);</li><li>location.reload() –重载当前页面</li></ul><p>（2）history对象</p><ul><li>history.go() – 前进或后退指定的页面树history.go(num)；</li><li>history.back()–后退一页</li><li>history.forward()–前进一页</li></ul><p>（3）Navigator对象</p><ul><li>navigator.userAgent – 返回用户代理头的字符串表示（就是包括浏览器版本信息等的字符串）</li><li>navigator.cookieEnabled – 返回浏览器是否支持（启用）cookie</li></ul><h3 id="1-9、说一下HTML5-drag-api"><a href="#1-9、说一下HTML5-drag-api" class="headerlink" title="1.9、说一下HTML5 drag api"></a>1.9、说一下HTML5 drag api</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在元素拖放被拖放元素时触发。</li><li>dragenter:  事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover:  事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave:  事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop:  事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend:  事件主体是被拖放元素，在整个拖放操作结束时触发<br>实例代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖动一张图片到浏览器中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#aaa</span>;</span></span><br><span class="line">            border-radius: 3px;</span><br><span class="line">            padding: 10px;</span><br><span class="line">            margin: 10px;</span><br><span class="line">            min-height: 400px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>拖放API的扩展知识<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>请拖动您的照片到下方方框区域<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   container.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   container.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> paper = e.dataTransfer.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> file = <span class="keyword">new</span> FileReader();</span></span><br><span class="line">        file.readAsDataURL(paper)</span><br><span class="line"><span class="javascript">       file.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件完成&#x27;</span>)</span></span><br><span class="line"><span class="javascript">           <span class="built_in">console</span>.log(file.result)</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line">            img.src =file.result;</span><br><span class="line">            container.appendChild(img)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Premise故事</title>
      <link href="2021/06/08/premise-gu-shi/"/>
      <url>2021/06/08/premise-gu-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是promise？"><a href="#什么是promise？" class="headerlink" title="什么是promise？"></a>什么是promise？</h2><p>故事带入：<br>假如有一对情侣，男的我们称呼为男人，女的我们称呼为女人。<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210608175102.png#height=178&id=AJCI2&originHeight=261&originWidth=388&originalType=binary&ratio=1&status=done&style=none&width=264"><br>这个女人承诺在情人节的时候给这个男人送一个孩子作为情人节礼物。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1623148161526-71889d9f-43bb-4c99-826d-2f551b74f779.png#clientId=uaf2afa43-c430-4&from=paste&height=110&id=u93749df2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=392&originalType=binary&ratio=2&size=52404&status=done&style=none&taskId=uacb6d319-61f1-4368-be2d-df126765e5e&width=196" alt="image.png"><br>这个承诺就会产生两个结果，要么成功怀孕，反之不成功。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1623148181703-815e7d76-a3d2-44ee-8ec8-e0fc6e881ba8.png#clientId=uaf2afa43-c430-4&from=paste&height=282&id=u386556ee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=973&originalType=binary&ratio=2&size=158608&status=done&style=none&taskId=u4428d9f0-d7f6-4666-9f17-4ab69588b1a&width=486.5" alt="image.png"><br>但是不管成功与否，都会在情人节之后结婚领证。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1623148194854-8c9e0e25-d42d-4614-b430-7f880a09c161.png#clientId=uaf2afa43-c430-4&from=paste&height=274&id=uac7b34d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=547&originWidth=1367&originalType=binary&ratio=2&size=229518&status=done&style=none&taskId=u8a9d9f5f-e59f-4e5e-9d57-b24d4b8d23a&width=683.5" alt="image.png"><br>其实这就是Promise的基本形式了。</p><p>1、首先这个女的进行了一个新的承诺，就是new了一个Promise。<br>2、这个Promise只会导致两种结果。<br>成功的话，就是解决了承诺，也就是resolve。<br>失败的话就是拒绝承诺，也就是reject。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1623148245874-53db34fb-647a-410c-88e6-f1adc1d256d7.png#clientId=uaf2afa43-c430-4&from=paste&height=308&id=ue7fb09b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=1229&originalType=binary&ratio=2&size=279736&status=done&style=none&taskId=ud55ad4eb-05d4-4963-b05a-3c2f908cec5&width=614.5" alt="image.png"><br>不管成功与否，毕竟怀孕这件事不是马上知道结果的，是需要一段时间才知道的。<br>所以Promise其实是回调的升级版，在处理一些需要花费比较长时间的任务时，使用Promise就可以进行异步的处理，防止阻塞。</p><p>当情人节过了以后，实际只有女人知道结果。如果女人告诉男人，那么那人将不得而知。<br>不过这个女人很会玩，成功的话她会称呼男人为孩子他爹，失败的话她会称呼男人为老公。<br>也就是说我们可以为resolve和reject里面传入参数，参数可以在后面进行使用。</p><p>现在就要女人来揭露承诺的时候了，如果成功的话女人就会用then来表示，因为她说：情人节然后我就怀孕了。直接用then表示成功。<br>如果失败的话女人就会用catch来表示，因为她会报的男人，抓着男人不放，叫一声老公让他心软。这里用catch来捕获失败。<br>不管是then，还是catch，最终他们还是结婚了。于是用finally来表示了。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1623148324859-ece851d2-956c-4c6c-ac7e-f05989c66cd4.png#clientId=uaf2afa43-c430-4&from=paste&height=304&id=u8fb9995d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=607&originWidth=1369&originalType=binary&ratio=2&size=329679&status=done&style=none&taskId=ude5b4268-e41f-4f44-9466-7e98cedd478&width=684.5" alt="image.png"></p><p>代码表示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> isPregnant = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(isPregnant)&#123;</span></span><br><span class="line"><span class="javascript">                resolve(<span class="string">&#x27;孩子他爹&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                reject(<span class="string">&#x27;老公&#x27;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        promise</span><br><span class="line"><span class="javascript">            .then( <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;男人成为了&#x27;</span>+name+<span class="string">&#x27;!&#x27;</span>);</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">            .catch( <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;男人成为了&#x27;</span>+name+<span class="string">&#x27;!&#x27;</span>);</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">            .finally(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;男人和女人结婚了！&#x27;</span>);</span></span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行机制</title>
      <link href="2021/05/13/javascript-zhi-xing-ji-zhi/"/>
      <url>2021/05/13/javascript-zhi-xing-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JavaScript是一门什么语言？"><a href="#1-JavaScript是一门什么语言？" class="headerlink" title="1.JavaScript是一门什么语言？"></a>1.JavaScript是一门什么语言？</h1><p>JavaScript是一门单线程语言，比如说页面上有一个DOM，一个线程删除此DOM节点，另一个线程给节点添加样式。</p><h1 id="2-同步和异步"><a href="#2-同步和异步" class="headerlink" title="2.同步和异步"></a>2.同步和异步</h1><p>JavaScript虽然是单线程语言，但是它有同步和异步的概念，解决了阻塞的问题。<br>同步：比如说在一个函数返回的时候，就能够得到预期结果：console.log()<br>异步：在函数返回的时候，调用者还得不到预期的结果，而是通过一定手段得到：setTimeout()</p><h1 id="3-任务队列"><a href="#3-任务队列" class="headerlink" title="3.任务队列"></a>3.任务队列</h1><p>同步任务：在主线程排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。<br>异步任务：不进入主线程。他进到专门存放异步任务的事件表里面去，当同步任务执行完成后在执行异步任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="4-宏任务"><a href="#4-宏任务" class="headerlink" title="4.宏任务"></a>4.宏任务</h1><p>宏任务有哪些：script整体代码，setTimeout，setInterval，I/O，UI交互。</p><h1 id="5-微任务"><a href="#5-微任务" class="headerlink" title="5.微任务"></a>5.微任务</h1><p>微任务主要包含：promise.then，process.nextuck</p><h1 id="6-JavaScript执行关键步骤"><a href="#6-JavaScript执行关键步骤" class="headerlink" title="6.JavaScript执行关键步骤"></a>6.JavaScript执行关键步骤</h1><p>1.执行一个宏任务（没有宏任务就从事件队列中获取）<br>2.执行过程中如果遇到微任务，就将它添加到微任务的任务对列中<br>3.宏任务执行完毕后，立即执行当前微任务的所有微任务<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210512113017.png" alt="执行步骤"><br>例子：<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210512113321.png" alt="例子"></p><h1 id="7-promise中的async-awite"><a href="#7-promise中的async-awite" class="headerlink" title="7.promise中的async/awite"></a>7.promise中的async/awite</h1><p>1.标有async的函数会立即执行，promise的异步体现在then和catch，所以说promise中的代码会立即执行。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件捕获和事件冒泡</title>
      <link href="2021/05/13/javascript-shi-jian-bu-huo-he-shi-jian-mou-pao/"/>
      <url>2021/05/13/javascript-shi-jian-bu-huo-he-shi-jian-mou-pao/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是事件冒泡？"><a href="#什么是事件冒泡？" class="headerlink" title="什么是事件冒泡？"></a>什么是事件冒泡？</h1><p>DOM事件流存在三个阶段：事件捕获阶段、处于目标阶段。事件冒泡阶段。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210513101604.png" alt="事件捕获"><br>通俗的理解就是，当鼠标点击或触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击子元素，如果父元素通过事件捕获的方式注册了对应的事件的话，会先触发父元素绑定的事件。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210513101441.png" alt="事件冒泡"><br>与事件捕获相反，事件冒泡顺序是由内到外进行事件传播，知道根节点。</p><h2 id="触发的先后顺序"><a href="#触发的先后顺序" class="headerlink" title="触发的先后顺序"></a>触发的先后顺序</h2><p>dom标准事件流的触发的先后顺序为：先捕获在冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。不同的浏览器对此有着不同的实现，<strong>IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在。</strong></p><h2 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener()方法"></a>addEventListener()方法</h2><p>这个方法设定一个事件监听器，当某一事件发生通过设定的参数执行操作。<br>语法：addEventListenser(event,function,useCapture)<br>参数<font color=red>event</font>是必须的，表示监听事件，例如click，touchstart等，就是之前不加前缀on的事件。<br>参数<font color=red>function</font>是必须的，表示事件触发后调用的函数，可以是外部定义函数，也可以是匿名函数。<br>参数useCapture是选填的，填true或者false，用于描述事件是冒泡还是捕获，true表示捕获，默认的false表示冒泡。</p><h2 id="移除事件监听"><a href="#移除事件监听" class="headerlink" title="移除事件监听"></a>移除事件监听</h2><p>如果要移除addEventListener()添加的事件监听，就要用removeEventListener()，语法是：removeEventListener(event,function)<br>参数与addEventListener()一致。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理（面试）</title>
      <link href="2021/04/14/wang-luo-yuan-li/"/>
      <url>2021/04/14/wang-luo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP、UDP、HTTP："><a href="#TCP、UDP、HTTP：" class="headerlink" title="TCP、UDP、HTTP："></a>TCP、UDP、HTTP：</h1><p>都是通信协议，也就是通信时所遵守的规则。</p><h1 id="TCP、UDP、HTTP三者的关系："><a href="#TCP、UDP、HTTP三者的关系：" class="headerlink" title="TCP、UDP、HTTP三者的关系："></a>TCP、UDP、HTTP三者的关系：</h1><p>TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。<br>网络层有：IP、ICMP、ARP、RARP、BPPTP协议。<br>传输层有：TCP与UDP<br>应用层有：FTP、HTTP、TELNET、SMTP、DNS等协议。</p><h1 id="socket："><a href="#socket：" class="headerlink" title="socket："></a>socket：</h1><p>为了实现通信协议的通信过程而建立成的通信管道，其真实的代表是客户端和服务器的一个通信进程，双方进程通过socket进行通信，而通信的规则采用指定的协议。socket只是一种连接模式，不是协议。</p><h1 id="OCI网络其层协议："><a href="#OCI网络其层协议：" class="headerlink" title="OCI网络其层协议："></a>OCI网络其层协议：</h1><p>应用层：<font size=2 color=red>与其他计算机进行通讯的一个应用，对应应用程序的通信服务的。示例：HTTP、FTP、SMTP、TELNET、NFS等。</font><br>表示层：<font size=2 color=red>主要功能定义数据格式及加密。示例：加密、ASCII等</font><br>会话层：<font size=2 color=red>定义如何开始、控制和结束一个会话。示例：RPC、SQL等</font><br>传输层：<font size=2 color=red>功能是否选择差错恢复协议还是无差错恢复协议，以及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺讯不对的数据包的重新排序功能。示例：TCP、UDP等</font><br>网络层：<font size=2 color=red>对端到端的包传输进行定义，标识所有的逻辑地址，定义路由实现方式和学习方式。示例：IP等</font><br>链路层：<font size=2 color=red>定义在单个连路上如何传输数据。示例：ATM、FDDI等</font><br>物理层：<font size=2 color=red>设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。</font></p><h1 id="TCP建立链接和断开链接过程"><a href="#TCP建立链接和断开链接过程" class="headerlink" title="TCP建立链接和断开链接过程:"></a>TCP建立链接和断开链接过程:</h1><p>建立TCP链接需要三次握手，<br>端来TCP链接需要四次挥手。</p><p>三次握手：<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210414125131.png" alt="三次握手"><br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，进入SYN_SENT状态，等待服务器确认，<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态，<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。<br>注：<br>SYN_RECV：一个连接请求已经到达，等待确认<br>SYN_SENT：应用已经开始，打开一个连接<br>ESTABLISHED：正常数据传输状态<br><font size=2>首先Client端发送连接请求报文，Server段接收连接后回复ACK报文（Acknowledgement，确认发来的数据已经接收完毕），为此次连接分配资源。Client端在收到ACK报文后也向Server端发送ACK报文，并分配资源，如此TCP连接就建立了。</font></p><p>四次挥手：<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210414125249.png" alt="四次挥手"></p><h1 id="HTTP8种请求方式："><a href="#HTTP8种请求方式：" class="headerlink" title="HTTP8种请求方式："></a>HTTP8种请求方式：</h1><p>GET：<font size=2 color=green>GET方法给定的URL从给定的服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应该对数据产生影响。GET请求是可缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏在书签中；且GET请求有长度限制，仅用于请求数据。注：GET请求不安全</font><br>POST：<font size=2 color=green>POST请求方法用于将数据发送到服务器一创建或更新资源。POST请求永远不会被缓存，且对数据长度没有限制</font><br>HEAD：<font size=2 color=green>与GET方法相同，但没有响应体，仅传输状态行和标题部分。</font><br>OPTIONS：<br>PUT：<br>DELETE：<br>TARACE：<br>CNNECT：</p><h1 id="GET与POST区别："><a href="#GET与POST区别：" class="headerlink" title="GET与POST区别："></a>GET与POST区别：</h1><p><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210414131613.png" alt="区别"></p><h1 id="怎么发送一个数据（json）呢？"><a href="#怎么发送一个数据（json）呢？" class="headerlink" title="怎么发送一个数据（json）呢？"></a>怎么发送一个数据（json）呢？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        url:&#39;$&#123;pageContext.request.contextPath &#125;&#x2F;rest&#x2F;jsonBody&#39;,</span><br><span class="line">        type:&#39;POST&#39;,</span><br><span class="line">        dataType:&#39;json&#39;,</span><br><span class="line">        contentType:&#39;application&#x2F;json;charset&#x3D;UTF-8&#39;,</span><br><span class="line">        data:JSON.stringify(data),</span><br><span class="line">        success:function(data, status)&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="2021/04/12/react/"/>
      <url>2021/04/12/react/</url>
      
        <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h1 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h1><p>首先要知道React是一个用于构建用户界面的JavaScript库，而非框架。<br>React主要用于构建UI，普遍认为React是MVC中的V。<br>React是Fackbook在2013年首次发布的。<br>React的功能仅仅是把组件渲染 成浏览器中的可见元素。<br>React生态圈组成了一个整体的灵活且可替换的框架。React拥有简洁的APT、神奇的生态圈以及很棒的社区。</p><h1 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1.Hello World"></a>1.Hello World</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">&lt;title&gt;Hello React!&lt;&#x2F;title&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;react&#x2F;16.4.0&#x2F;umd&#x2F;react.development.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;react-dom&#x2F;16.4.0&#x2F;umd&#x2F;react-dom.development.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.staticfile.org&#x2F;babel-standalone&#x2F;6.26.0&#x2F;babel.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h1 id="2-JSX简介"><a href="#2-JSX简介" class="headerlink" title="2.JSX简介"></a>2.JSX简介</h1><p>JSX声明方式：<br><code>const element=&lt;h1&gt;Hello World!&lt;/h1&gt;;</code></p><p>JSX:JSX是一种Javas的语法扩展，运用于React架构中。元素是构成React最小的单位，JSX就是用来声明React当中的元素，React使用JSX来描述用户界面。<br>JSX将HTML语法直接加入到JavaScript代码中，再通过翻译器转换到纯JavaScript后由浏览器执行。。</p><h2 id="2-1为什么使用JSX"><a href="#2-1为什么使用JSX" class="headerlink" title="2.1为什么使用JSX"></a>2.1为什么使用JSX</h2><p>React认为渲染逻辑本质上与其他UI逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。而JSX很好地解决了一问题。</p><h2 id="2-2在JSX中嵌入表达式"><a href="#2-2在JSX中嵌入表达式" class="headerlink" title="2.2在JSX中嵌入表达式"></a>2.2在JSX中嵌入表达式</h2><p>上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const name &#x3D; lihao;</span><br><span class="line">const element &#x3D; &lt;h1&gt;Hello,&#123;name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">element,</span><br><span class="line">document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>声明一个变量name，然后再JSX中使用它，并将它包裹在大括号中。</p><h1 id="3-React组件"><a href="#3-React组件" class="headerlink" title="3.React组件"></a>3.React组件</h1><p>组件是React的核心内容，是View的组成部分，每一个View都由一个或多个组件构成，可以说组件是React应用程序的根基。</p><h2 id="3-1无状态组件"><a href="#3-1无状态组件" class="headerlink" title="3.1无状态组件"></a>3.1无状态组件</h2><p>没有状态控制的组件，只作为纯静态展示作用，无状态组件也是最基本的组件形式，它由属性props和渲染函数render构成。由于不涉及到状态的更新，所以这种组件的复用性也是最强的。<br>函数定义的组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function HelloMessage(props) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const element &#x3D; &lt;HelloMessage &#x2F;&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>EE6标准定义类组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2有状态组件"><a href="#3-2有状态组件" class="headerlink" title="3.2有状态组件"></a>3.2有状态组件</h2><p>有状态组件是在无状态组件的基础上增加了组件内部状态管理，有状态组件通常会带有生命周期lifecycle，用以在不同的时刻触发状态的更新，有状态组件被大量用在业务逻辑开发中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Home extends React.Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;;</span><br><span class="line">    render ()&#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Header name&#x3D;&quot;子组件实例上props属性&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Header extends React.Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">&lt;div&gt;&#123;this.props.name&#125;&lt;&#x2F;div&gt; &#x2F;&#x2F;构造函数中并没有传递props属性，</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由上面的例子中我们可以发现，获取实例属性的适合要通过this来访问，去掉this就获取不到了。<br>下面我们在constructor构造函数中传递一个props参数，通过什么样的方式访问子组件实例上的props属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Header extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.name &#x3D; props.name;  &#x2F;&#x2F;获取到子组件实例上的props.name属性，赋值给实例属性name</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&#123;this.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们经常会发现super(props)，为什么super()中还要传递一个props属性呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Header extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            nameOne: props.name,</span><br><span class="line">            nameTwo: this.props.name  &#x2F;&#x2F;super()方法中传递了props属性，this.props才可以获取到name属性</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&#123;this.state.nameOne&#125;&#123;this.state.nameTwo&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实，props.name和this.props.name的值都是一样的，但是它俩还是有区别的，props.name中这个props就是子组件的属性props，但是this.props.name中的这个props却不是子组件的属性props，虽然值都是一样的，这个props其实在调用super方法的时候被传递到了Component这个父类中去了，所以this.props.name获取到的是Component父类中的props属性。</p><h1 id="4-React数据流"><a href="#4-React数据流" class="headerlink" title="4.React数据流"></a>4.React数据流</h1><p>在React中，数据是自顶向下单向流动的，从父组件到子组件。这条原则让组件之间的关系变的可以预测。</p><h2 id="4-1state"><a href="#4-1state" class="headerlink" title="4.1state"></a>4.1state</h2><p>state 是组件内部状态，修改 state 的值修改需要通过 setState 方法，禁止直接修改 state，setState 是一个异步方法，修改完成会有一个回调方法，一个生命周期内所有 setState 方法会合并统一操作。<br>不推荐过多的使用 state，当数据更新同时需要更新界面的时候，才使用 state，并且尽量将 state 推到系统边缘，统一管理 state。过多的内部状态会让数据流混乱，程序变得难以维护。</p><h2 id="4-2props"><a href="#4-2props" class="headerlink" title="4.2props"></a>4.2props</h2><p>props 是 properties 缩写，是 React 用来让组件之间相互联系的一种机制。<br>React 的单向数据流，主要的流动管道就是 props，props 本身是不可变的。<br>注意：父组件传递的 props，作为子组件的 state，会产生引用对象影响问题，也就是赋值是一个浅复制，会导致 state 改变进而导致 父组件的 props 改变</p><h2 id="4-3state和props对比"><a href="#4-3state和props对比" class="headerlink" title="4.3state和props对比"></a>4.3state和props对比</h2><ul><li>prop 用于定义外部接口，state用于纪录内部状态；</li><li>prop 的赋值在外部使用组件时，state 的赋值在组件内部；</li><li>组件不应该改变 prop 的值，而 state 存在的目的就是让组件来改变。</li></ul><h1 id="5-React生命周期"><a href="#5-React生命周期" class="headerlink" title="5.React生命周期"></a>5.React生命周期</h1><p>学习React，生命周期方法尤其重要，熟练使用生命周期方法可以大大提高组件的复用率，提高组件的性能。</p><h2 id="5-1生命周期"><a href="#5-1生命周期" class="headerlink" title="5.1生命周期"></a>5.1生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/1568627849940-5761e9a2-e55f-4a75-8ded-731429b37c45.jpeg" alt="alt 生命周期"></p><h2 id="5-2生命周期阶段"><a href="#5-2生命周期阶段" class="headerlink" title="5.2生命周期阶段"></a>5.2生命周期阶段</h2><p>有些人认为将初始化和挂载都归为初始化阶段。但是我们再详细一点，将初始化阶段拆分开来。<br>生命周期四个阶段：1.初始化 2.挂载 3.更新 4.销毁。</p><h3 id="5-2-1初始化"><a href="#5-2-1初始化" class="headerlink" title="5.2.1初始化"></a>5.2.1初始化</h3><p>初始化阶段我们用到的最多的其实就是类的构造方法 constructor(props) super(props) 在构造方法中我们一般做的事情就是初始化某个状态，数据。</p><h3 id="5-2-2挂载"><a href="#5-2-2挂载" class="headerlink" title="5.2.2挂载"></a>5.2.2挂载</h3><p>挂载顺序：componentWillMount() –&gt; render() –&gt; componentDidMount()<br><strong>1. componentWillMount()</strong><br>该声明周期方法在组件挂载到DOM前调用，且只会被调用一次，这个方法正确调用的时候是在component第一次render之前,  所以第一眼看上去觉得就应该在这里去fetch datas. 但是这里有个问题,  在异步请求数据中这一次返回的是空数据, 因为是在 render 之前不会返回数据. 所以在渲染的时候没有办法等到数据到来,也不能在componentWillMount中返回一个Promise（因为Promise的特性之一就是状态不可变）。<br><strong>2. render()</strong><br>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行，此时不能修改state了<br><strong>3. componentDidMount()</strong><br>该声明周期方法在组件挂载到DOM后调用，且只会被调用一次。在生产时,componentDidMount生命周期函数是最好的时间去请求数据，其中最重要原因：使用componentDidMount第一个好处就是这个一定是在组件初始化完成之后，再会请求数据，因此不会报什么警告或者错误，我们正常请教数据完成之后一般都会setState。</p><h3 id="5-2-3更新"><a href="#5-2-3更新" class="headerlink" title="5.2.3更新"></a>5.2.3更新</h3><p><strong>4. componentWillReceiveProps(nextProps)</strong><br>组件初始化和挂载时不调用，组件接受新的props时调用<br><strong>5. shouldComponentUpdate(nextProps, nextState)</strong><br>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候<br><strong>6. componentWillUpdata(nextProps, nextState)</strong><br>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state<br><strong>7. componentDidUpdate()</strong><br>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p><h3 id="5-2-4销毁"><a href="#5-2-4销毁" class="headerlink" title="5.2.4销毁"></a>5.2.4销毁</h3><p><strong>8.componentWillUnmount()</strong><br>组件将要卸载时调用，一些事件监听和定时器需要在此时清除，以免引起内存泄漏。</p><h1 id="6-React事件系统"><a href="#6-React事件系统" class="headerlink" title="6. React事件系统"></a>6. React事件系统</h1><p>React事件绑定的属性的命名采用的是小驼峰式写法，而不是小写。<br><code>&lt;button onclick=&#123;activateLasers&#125;&gt;Activate Lasers&lt;/button&gt;</code><br>在React中你不能通过使用返回false的方式阻止默认行为。你必须使用preventDefault的方法。<br>//传统的HTML中阻止链接默认打开一个新页面，你可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;#&quot; onclick&#x3D;&quot;console.log(&#39;The link was clicked.&#39;);return false&quot;&gt;Click me&lt;&#x2F;a&gt;</span><br><span class="line">&#x2F;&#x2F;在React该这样写哦</span><br><span class="line">function ActionLink()&#123;</span><br><span class="line">    function handleClick(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#39;The link was clicked.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  return(</span><br><span class="line">    &lt;a href&#x3D;&quot;#&quot;onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;&#x2F;a&gt;  </span><br><span class="line">  ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-1关于e的理解"><a href="#6-1关于e的理解" class="headerlink" title="6.1关于e的理解"></a>6.1关于e的理解</h2><p>e是一个合成事件，同时它也是个参数。<br>使用React的时候通常你不需要使用addEventListener为一个已经创建的DOM元素添加监听器。你仅仅需要在这个元素初始化渲染的时候提供一个监听器。<br><strong>this</strong></p><ul><li>谁调用this就指向谁</li><li>es6箭头函数直接指向父层</li><li> 部分直接指向windows<br>首先类的方法默认是不会绑定this的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。<br>举个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state&#x3D;&#123;</span><br><span class="line">        mag:&#39;我是Home的事件&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;</span><br><span class="line">      alert(&#39;错啦！我是点击的事件&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">      return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;this.run&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;  </span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>我们点击触发，会弹出run()函数中的内容。<br>来看看下面的这个，假如我们需要在方法中使用数据呢？我们想把“我是home事件弹出来”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">      mag:&#39;我是Home的事件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    alert(this.state.mag);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.run&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这时需要改变this的指向，才能正确显示<br>通过在onClick中指明当前应该指向Ape。使用bind()方法.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">      mag:&#39;我是Home的事件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    alert(this.state.mag);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.run.bind(this)&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>• 在构造函数中改变this的指向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">      mag:&#39;我是Home的事件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    this.run &#x3D; this.run.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  run()&#123;</span><br><span class="line">    alert(this.state.mag);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.run&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>• 通过箭头函数改变this的指向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">      mag:&#39;我是Home的事件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    this.run &#x3D; this.run.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  run &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">    alert(this.state.mag);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.run&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;你也可以这样</span><br><span class="line">class Apa extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state&#x3D;&#123;</span><br><span class="line">      mag:&#39;我是Home的事件&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    this.run &#x3D; this.run.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  run ()&#123;</span><br><span class="line">    alert(this.state.mag);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;this.state.mag&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.run()&#125;&gt;触发&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;注意后面的run后面有()</span><br></pre></td></tr></table></figure>• 此外再扩展一个双冒号法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Home extends React.Component &#123;</span><br><span class="line"> constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state &#x3D; &#123;</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> del()&#123;</span><br><span class="line">  console.log(&#39;del&#39;)</span><br><span class="line"> &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line">  return (</span><br><span class="line">   &lt;div className&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;span onClick&#x3D;&#123;::this.del&#125;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以发现，双冒号法必须在没有传参的条件下运用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础（二）</title>
      <link href="2021/04/12/qian-duan-ji-chu-er/"/>
      <url>2021/04/12/qian-duan-ji-chu-er/</url>
      
        <content type="html"><![CDATA[<h1 id="一-前端基础"><a href="#一-前端基础" class="headerlink" title="一.前端基础"></a>一.前端基础</h1><h2 id="2-HTTP、HTML、浏览器"><a href="#2-HTTP、HTML、浏览器" class="headerlink" title="2.HTTP、HTML、浏览器"></a>2.HTTP、HTML、浏览器</h2><h3 id="2-0、说一下http2-0"><a href="#2-0、说一下http2-0" class="headerlink" title="2.0、说一下http2.0"></a>2.0、说一下http2.0</h3><p>首先补充一下，http和https的区别，相比http，https是基于ssl加密的http协议。<br>http2.0是基于1999年发布的http1.0之后的首次更新<br>提升了访问速度<br>允许多路复用<br>二进制分帧：http2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码<br>首部压缩<br>服务器端推送</p><h3 id="2-1、补充400和401、403状态码"><a href="#2-1、补充400和401、403状态码" class="headerlink" title="2.1、补充400和401、403状态码"></a>2.1、补充400和401、403状态码</h3><p>（1）400状态码：请求无效<br>产生原因：<br>前端提交数据的字段名称和字段类型与后台的实体没有保持一致<br>前端提交到后台的数据应该是JSON字符串类型，但是前端没有将对象json.stringify转化成字符串。<br>解决办法：<br>对照字段名称，保持一致性<br>将obj对象通过JSON.stringify实现序列化<br>（2）401状态码：当前请求需要用户验证<br>（3）403状态码：服务器已经得到请求，但是拒绝执行</p><h3 id="2-2、fetch发送2次请求的原因"><a href="#2-2、fetch发送2次请求的原因" class="headerlink" title="2.2、fetch发送2次请求的原因"></a>2.2、fetch发送2次请求的原因</h3><p>fetch发送两次post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？<br>因为用fetch的post请求的时候，导致fetch第一次发送了一个options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p><h3 id="2-3、Cookie、sessionStorage、localStorage的区别"><a href="#2-3、Cookie、sessionStorage、localStorage的区别" class="headerlink" title="2.3、Cookie、sessionStorage、localStorage的区别"></a>2.3、Cookie、sessionStorage、localStorage的区别</h3><p>共同点：都是保存在浏览器端，并且是同源的</p><p>Cookie：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径的概念，可以限制cookie只属于某个路径下，存储的大小很小只用4k左右。（简洁：可以在浏览器和服务器之间来回传递，储存容量小，只有大约4k左右）</p><p>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不能持久保持。（本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当前页面不同即使同一页面打开两次，也被视为同一次回话）<br>locaStorage：始终有效，窗口或者浏览器关闭也一直保存，因此用作持久数据。<br>cookie：只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><p>localStorage： localStorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口都是共享的。（同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</p><p>补充说明cookie的作用：<br>保存用户登录状态。<br>跟踪用户行为。<br>定制页面。</p><h3 id="2-4、说一下web-worker"><a href="#2-4、说一下web-worker" class="headerlink" title="2.4、说一下web worker"></a>2.4、说一下web worker</h3><p>在HTML页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应的 。web worker是运行在后台的js，独立于其他脚本，不会影响页面的性能。并且通过postMessage将数据回传到主线程。这样在进行复杂的操作的时候，就不会阻塞主线程了。</p><p>如何创建web worker：<br>检测浏览器是否支持<br>创建web worker文件（js，回传函数等）<br>创建web worker对象</p><h3 id="2-5、对HTML语义化标签的理解"><a href="#2-5、对HTML语义化标签的理解" class="headerlink" title="2.5、对HTML语义化标签的理解"></a>2.5、对HTML语义化标签的理解</h3><p>HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer、等等。</p><h3 id="2-6、iframe是什么？有什么缺点？"><a href="#2-6、iframe是什么？有什么缺点？" class="headerlink" title="2.6、iframe是什么？有什么缺点？"></a>2.6、iframe是什么？有什么缺点？</h3><p>定义：iframe元素会创建包含另一个文档的内联框架。<br>缺点：会阻塞主页的onload事件<br>搜索引擎无法解读这种页面，不利于SEO<br>iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</p><h3 id="2-7、Doctype作用？严格模式与混杂模式如何区分？它们有何意义？"><a href="#2-7、Doctype作用？严格模式与混杂模式如何区分？它们有何意义？" class="headerlink" title="2.7、Doctype作用？严格模式与混杂模式如何区分？它们有何意义？"></a>2.7、Doctype作用？严格模式与混杂模式如何区分？它们有何意义？</h3><p>Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。<br>严格模式的排版和js运作模式是以该浏览器支持的最高运行标准运行。<br>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p><h3 id="2-8、cookie如何防范XSS攻击"><a href="#2-8、cookie如何防范XSS攻击" class="headerlink" title="2.8、cookie如何防范XSS攻击"></a>2.8、cookie如何防范XSS攻击</h3><p>XSS（跨域脚本攻击）是指攻击者再返回的HTML中嵌如JavaScript脚本，为了减轻这些攻击，需要在http头部配上，set-cookie；<br>httponly - 这个属性可以防止XSS，它会禁止JavaScript脚本来访问cookie<br>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie<br>结果应该是这样的：<code>Set-Cookie=&lt;cookie-value&gt;......</code></p><h3 id="2-9、-cookie和session的区别"><a href="#2-9、-cookie和session的区别" class="headerlink" title="2.9、 cookie和session的区别"></a>2.9、 cookie和session的区别</h3><p>http是一个无状态协议，因此cookie的最大的作用就是存储sessionId用户唯一标识用户</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础（一）</title>
      <link href="2021/04/12/qian-duan-ji-chu-yi/"/>
      <url>2021/04/12/qian-duan-ji-chu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前端基础"><a href="#一、前端基础" class="headerlink" title="一、前端基础"></a>一、前端基础</h1><h2 id="1-HTTP，HTML，浏览器"><a href="#1-HTTP，HTML，浏览器" class="headerlink" title="1.HTTP，HTML，浏览器"></a>1.HTTP，HTML，浏览器</h2><h3 id="1-1、说一下http和https"><a href="#1-1、说一下http和https" class="headerlink" title="1.1、说一下http和https"></a>1.1、说一下http和https</h3><p>https的SSL加密是在传输层实现的。<br>（1）http和https的基本概念<br>http：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是客户端和服务端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以是浏览器更加高效，使网络传输减少。</p><p>https：是以安全为目标的http通道，简单的说就是http的安全版，即http下加入SSL层，https的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p>https协议的主要作用：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p><p>（2）http和https的区别？<br>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单的来说https协议是由http和SSl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要区别：</p><ul><li>https协议需要ca证书，费用较高。</li><li>http是超文本传输协议，信息是明文传输，https则具有安全性的ssl加密传输协议。</li><li>不同的链接方式，端口也不同，一般而言，http协议端口为80，https的端口为443。</li><li>http链接很简单，是无状态的；https协议是由SSL+http协议构成的可进行加密传输、身份认证的网洛协议，比http协议安全。</li></ul><p>（3）https协议的工作原理<br>客户端在使用https方式与Web服务器通信时有一下几个步骤。</p><ol><li>客户端使用https+url访问服务器，则需要web服务器建立ssl链接。</li><li>web服务器接受客户端的请求后，会将网站的证书（证书包含了公钥），返回或者传输给客户端。</li><li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方的协商一致的安全等级，建立会话秘钥，然后通过网站的公钥来加密会话秘钥，并传送给网站。</li><li>web服务器通过自己的私钥解密出会话秘钥。</li><li>web服务器通过会话秘钥加密与客户端之间的通信。</li></ol><p>（4）https协议的优点</p><ul><li>使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>https协议是由SSL+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输构成中不被窃取、改变，确保数据的完整性。</li><li>https是先行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>比起同等http网站，采用https加密的网站在搜索结果中的排名将会更高。</li></ul><p>（5）https协议的缺点</p><ul><li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%·20%的耗电。</li><li>https缓存不如http高效，会增加数据开销。</li><li>SSL证书也需要钱，功能越强大的证书费用越高。</li><li>SSL证书需要绑定IP，不能在同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li></ul><h3 id="1-2、tcp三次握手"><a href="#1-2、tcp三次握手" class="headerlink" title="1.2、tcp三次握手"></a>1.2、tcp三次握手</h3><p>客户端和服务端都需要直到各自可收发，因此需要三次握手。<br>简化三次握手：<br><img src="https://cdn.jsdelivr.net/gh/521129/Jsd@main/img/20210413132536.png" alt="三次握手"><br>图片解析：C发起请求链接S确认，也发起链接C确认<br>每次握手的作用：<br>    第一次握手：S只可以确认，自己可以接受C发送的报文段<br>    第二次握手：C可以确认S收到了自己发送的报文段，并且可以确认自己可以接受S发送的报文端<br>    第三次握手：S可以确认C收到了自己发送的报文段</p><h3 id="1-3、TCP和UDP的区别"><a href="#1-3、TCP和UDP的区别" class="headerlink" title="1.3、TCP和UDP的区别"></a>1.3、TCP和UDP的区别</h3><ol><li>TCP是面向链接的，UDP是无连接的即发送数据前不需要先建立链接。</li><li>TCP提供可靠的服务。也就是说，通过TCP链接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</li><li>TCP是面向字节流，UDP面向报文，并且网络出现拥塞不使得发送率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</li><li>TCP只能是1对1的，UDP支持1对1，1对多。</li><li>TCP的首部较大为20字节，而UDP只有8字节。</li><li>TCP是面向链接的可靠性传输，而UDP是不可靠的。</li></ol><h3 id="1-4、WebSocket的实现和应用"><a href="#1-4、WebSocket的实现和应用" class="headerlink" title="1.4、WebSocket的实现和应用"></a>1.4、WebSocket的实现和应用</h3><p>（1）什么是WebSocket？<br>WebSocket是HTML5中的协议，支持持久连续。http协议不支持持久性连接。HTTP1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的Keep-alive，将多个http请求合并为1个。<br>（2）WebSocket是什么样的协议，具体有什么优点？<br>HTTP的声明周期通过Request来界定，也就是Request一个Response，那么在HTTP1.0协议中，这次HTTP请求就结束了。在HTTP1.1中进行了改进，是有一个connection：keep-alive，也就是说，在一个http连接中，可以发送多个Request，接受多个Response。但是，在http中一个Request只能对应一个Response，而且这个Response是被动的，不能主动发起。</p><p>WebSocket是基于HTTP协议的，或者说借用了HTTP协议完成了一部分握手，在握手阶段与http是相同的。<br>我们来看一个WebSocket协议的实现，基本是2个属性，upgrade，connection。<br>基本请求如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1、1</span><br><span class="line">Host: server. examp1e.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-webSocket-Protoco1: chat,superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http: //examp1e.com</span><br><span class="line">多了下面2个属性:</span><br><span class="line">Upgrade: webSocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">告诉服务器发送的是websocket</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">sec-WebSocket-Protoco1 : chat，superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><h3 id="1-5、HTTP请求的方式，HEAD方式"><a href="#1-5、HTTP请求的方式，HEAD方式" class="headerlink" title="1.5、HTTP请求的方式，HEAD方式"></a>1.5、HTTP请求的方式，HEAD方式</h3><p>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。<br>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</p><h3 id="1-6、一个图片url访问后直接下载怎样实现？"><a href="#1-6、一个图片url访问后直接下载怎样实现？" class="headerlink" title="1.6、一个图片url访问后直接下载怎样实现？"></a>1.6、一个图片url访问后直接下载怎样实现？</h3><p>请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为参数。<br>下载的情况：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、x-oss-object-type:</span><br><span class="line">Norma1</span><br><span class="line">2、x-oss-request-id:</span><br><span class="line">598D5ED34F29DO1FE2925F41</span><br><span class="line">3、x-oss-storage-c1ass:</span><br><span class="line">Standard</span><br></pre></td></tr></table></figure><h3 id="1-7、说一下web-Quality（无障碍）"><a href="#1-7、说一下web-Quality（无障碍）" class="headerlink" title="1.7、说一下web Quality（无障碍）"></a>1.7、说一下web Quality（无障碍）</h3><p>能够被残障人士使用的网站才能称得上一个易用（易访问的）网站。</p><p>例如：<br>使用alt属性：<br><code>&lt;img src=&quot;preson.jpg&quot; alt=&quot;this is person&quot; /&gt;</code><br>有时候浏览器会无法显示图像。<br>具体原因有：</p><ul><li>用户关闭图像显示</li><li>浏览器不支持图像显示的迷你浏览器</li><li>浏览器是语音浏览器（供盲人和弱视人群使用）</li></ul><p>使用alt属性，那么浏览器至少可以显示或读出有关图像的描述。</p><h3 id="1-8、几个实用的BOM属性对象方法"><a href="#1-8、几个实用的BOM属性对象方法" class="headerlink" title="1.8、几个实用的BOM属性对象方法?"></a>1.8、几个实用的BOM属性对象方法?</h3><p>什么是BOM？BOM是浏览器对象。<br>（1）location对象</p><ul><li>location.href–返回或设置当前文档的URL</li><li>location.search – 返回URL中的查询字符串部分。例如http: //<a href="http://www.dreamdu.com/dreamdu">www.dreamdu.com/dreamdu</a>. php?id=5&amp;name=dreamdu返回包括(?)后面的内容?id=5&amp;name=dreamdu</li><li>location.hash –返回URL#后面的内容，如果没有#，返回空location.host –返回URL中的域名部分，例如 www. dreamdu.comlocation.hostname –返回URL中的主域名部分，例如 dreamdu.com</li><li>location.pathname –返回URL的域名后的部分。例如 <a href="http://www/">http://www</a>. dreamdu.com/xhtml/返回/xhtml/</li><li>location. port –返回URL中的端口部分。例如 <a href="http://www/">http://www</a>. dreamdu.com:8080/xhtml/返回8080</li><li>location.protocol – 返回URL中的协议部分。例如http: / / <a href="http://www.dreamdu.com:8080/xhtml/%E8%BF%94%E5%9B%9E(//)%E5%89%8D%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9http:location.assign">www.dreamdu.com:8080/xhtml/返回(//)前面的内容http:location.assign</a> –设置当前文档的URL</li><li>location.replace() –设置当前文档的URL，并且在history对象的地址列表中移除这个URL</li><li>location.replace(url);</li><li>location.reload() –重载当前页面</li></ul><p>（2）history对象</p><ul><li>history.go() – 前进或后退指定的页面树history.go(num)；</li><li>history.back()–后退一页</li><li>history.forward()–前进一页</li></ul><p>（3）Navigator对象</p><ul><li>navigator.userAgent – 返回用户代理头的字符串表示（就是包括浏览器版本信息等的字符串）</li><li>navigator.cookieEnabled – 返回浏览器是否支持（启用）cookie</li></ul><h3 id="1-9、说一下HTML5-drag-api"><a href="#1-9、说一下HTML5-drag-api" class="headerlink" title="1.9、说一下HTML5 drag api"></a>1.9、说一下HTML5 drag api</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在元素拖放被拖放元素时触发。</li><li>dragenter:  事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover:  事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave:  事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop:  事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend:  事件主体是被拖放元素，在整个拖放操作结束时触发<br>实例代码：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖动一张图片到浏览器中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        body&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#aaa</span>;</span></span><br><span class="line">            border-radius: 3px;</span><br><span class="line">            padding: 10px;</span><br><span class="line">            margin: 10px;</span><br><span class="line">            min-height: 400px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>拖放API的扩展知识<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>请拖动您的照片到下方方框区域<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   <span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   container.ondragover = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">       e.preventDefault()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="javascript">   container.ondrop = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> paper = e.dataTransfer.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> file = <span class="keyword">new</span> FileReader();</span></span><br><span class="line">        file.readAsDataURL(paper)</span><br><span class="line"><span class="javascript">       file.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;读取文件完成&#x27;</span>)</span></span><br><span class="line"><span class="javascript">           <span class="built_in">console</span>.log(file.result)</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line">            img.src =file.result;</span><br><span class="line">            container.appendChild(img)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2021/04/01/ajax/"/>
      <url>2021/04/01/ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>Ajax全称：Asynchronous JavaScript and XML（异步的JavaScript和XML），Ajax一般作用就是Javascript执行异步网络请求，Ajax最大的优点就是在不重新加载整个页面的情况下，可以与服务器交换数据更新部分网页内容，Ajax不需要插件，但是需要用户允许JavaScript在浏览器上面执行。</p><p>一个完整的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadXMLDoc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>使用 AJAX 修改该文本内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;loadXMLDoc()&quot;</span>&gt;修改内容&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="一-XMLHttpRequest"><a href="#一-XMLHttpRequest" class="headerlink" title="一.XMLHttpRequest"></a>一.XMLHttpRequest</h2><p>XMLHttpRequest是一个对象，现在几乎所有的浏览器都支持该对象了（IE5和IE6使用的ActiveXObiect）<br>XMLHttpRequest用于后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line">if (window.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line">    xmlhttp&#x3D;new XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class="line">    xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-向服务器发送请求"><a href="#二-向服务器发送请求" class="headerlink" title="二.向服务器发送请求"></a>二.向服务器发送请求</h2><p>如需将请求发送到服务器，我们使用XMLHttpRequest对象的open()和send()方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>open(method,url,async)</td><td>规定请求类型、URL以及是否异步处理请求。</td></tr></tbody></table><ul><li>async：true（异步）或false（同步）</li><li>url：文件在服务器的位置</li><li>method：请求的类型；GET或POST<br>|<br>|  |<br>|  |<br>|  |<br>| send(string) | 将请求发送到服务器。string：仅用于POST请求 |</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;ajax_info.txt&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><h2 id="三-GET请求和POST请求"><a href="#三-GET请求和POST请求" class="headerlink" title="三.GET请求和POST请求"></a>三.GET请求和POST请求</h2><p>GET：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;&#x2F;try&#x2F;ajax&#x2F;demo_get.php?fname&#x3D;Henry&amp;lname&#x3D;Ford&quot;,true);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>POST:<br>如果需要像HTML表单那样POST数据，请使用setRequestHeader()来添加HTTP头。然后在send()方法中规定您希望发送的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;&#x2F;try&#x2F;ajax&#x2F;demo_post2.php&quot;,true);</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;);</span><br><span class="line">xmlhttp.send(&quot;fname&#x3D;Henry&amp;lname&#x3D;Ford&quot;);</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setRequestHeader(header,Value)</td><td>向请求添加HTTP头。</td></tr><tr><td>header：规定头的名称；</td><td></td></tr><tr><td>value：规定头的值。</td><td></td></tr></tbody></table><p>与POST相比，GET更简单也更快，并且在大部分情况下都能用。<br>然而，在一下情况中，请使用POST请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量的数据（POST没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST比GET更稳更可靠</li></ul><p>XMLHttpRequest对象如果要用于AJXS的话，其open()方法的async参数必须设置为true。<br>当使用async=true时，请规定在响应处于onreadysatechange事件中的就绪状态时执行的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;ajxs_test.html&quot;,true);</span><br></pre></td></tr></table></figure><p>如需使用async=false，请将open()方法中的第三个参数改为false：我们不推荐使用async=false，但是对于一些小型的请求，也可以的。<br>记住，JavaScript会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。<br><strong>注意</strong>：当您使用async=false时，请不要编写onreadystatechange函数 - 把代码放到send()语句后面即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;&#x2F;try&#x2F;ajax&#x2F;ajax_info.txt&quot;,false);</span><br><span class="line">xmlhttp.send();</span><br><span class="line">document.getElementById(&quot;myDiv&quot;).innerHTML&#x3D;xmlhttp.responseText;</span><br></pre></td></tr></table></figure><h2 id="四-服务器响应"><a href="#四-服务器响应" class="headerlink" title="四.服务器响应"></a>四.服务器响应</h2><p>如需获得来自服务器的响应，请使用XMLHttpRequest对象的responseText或responseXML属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>responseText</td><td>获得字符串形式的响应数据。</td></tr><tr><td>responseXML</td><td>获得XML形式的响应数据。</td></tr></tbody></table><h2 id="五-onreadystatechange事件"><a href="#五-onreadystatechange事件" class="headerlink" title="五.onreadystatechange事件"></a>五.onreadystatechange事件</h2><p>当请求被发送到服务器时，我们需要执行一些基于响应的任务。<br>每当readyState改变时，就会触发onreadystatechange事件。<br>readyState属性存有XMLHttpRequest的状态信息。<br>下面是XMLHttpRequest对象的三个重要的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当readyState属性改变时，就会调用该函数</td></tr><tr><td>redyState</td><td>存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</td></tr><tr><td>0: 请求未初始化</td><td></td></tr><tr><td>1: 服务器连接已建立</td><td></td></tr><tr><td>2: 请求已接收</td><td></td></tr><tr><td>3: 请求处理中</td><td></td></tr><tr><td>4: 请求已完成，且响应已就绪</td><td></td></tr><tr><td>status</td><td>200：“ok”；</td></tr><tr><td>404：没找到页面</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE3.x增加哪些内容</title>
      <link href="2021/04/01/vue3.x-zeng-jia-na-xie-nei-rong/"/>
      <url>2021/04/01/vue3.x-zeng-jia-na-xie-nei-rong/</url>
      
        <content type="html"><![CDATA[<h1 id="该文档解决了哪些问题？"><a href="#该文档解决了哪些问题？" class="headerlink" title="该文档解决了哪些问题？"></a>该文档解决了哪些问题？</h1><ul><li>VUE3.x增加哪些内容？</li><li>VUE3.x增加了那些api？</li><li>VUE3.x为什么变快了？</li></ul><h1 id="一。vue3增加了那些内容？"><a href="#一。vue3增加了那些内容？" class="headerlink" title="一。vue3增加了那些内容？"></a>一。vue3增加了那些内容？</h1><p><strong>1.浏览器性能提升</strong><br><strong>2.底层实现方法优化</strong><br>增加Proxy<br><strong>3.切换到TypeScript</strong><br><strong>4.克服虚拟DOM的瓶颈</strong><br><strong>5.打包体积变小</strong></p><h1 id="二。vue3增加了哪些api？"><a href="#二。vue3增加了哪些api？" class="headerlink" title="二。vue3增加了哪些api？"></a>二。vue3增加了哪些api？</h1><h2 id="1-初始话项目"><a href="#1-初始话项目" class="headerlink" title="1.初始话项目"></a>1.初始话项目</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ① npm i -g @vue/cli</span></span><br><span class="line"><span class="comment">// ② vue create my-project</span></span><br><span class="line"><span class="comment">// ③ npm install @vue/composition-api -S</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ④ main,js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueCompositionApi <span class="keyword">from</span> <span class="string">&#x27;@vue/composition-api&#x27;</span></span><br><span class="line">Vue.use(VueCompositionApi)</span><br></pre></td></tr></table></figure><h2 id="2-setup方法"><a href="#2-setup方法" class="headerlink" title="2.setup方法"></a>2.setup方法</h2><p>setup是vue3.x中新的操作组件属性的方法，它是组件内部暴露出所有的属性和方法的统一api。</p><h2 id="3-reactive"><a href="#3-reactive" class="headerlink" title="3.reactive"></a>3.reactive</h2><p>reactive函数接受一个普通函数，返回下一个响应式的数据对象。<br>reactive函数等价于vue2.x中的Vue.observable()函数，vue3.x中提供了reactive()函数，用来创建响应式的数据对象。</p><h2 id="4-ref"><a href="#4-ref" class="headerlink" title="4.ref"></a>4.ref</h2><p>ref() 函数用来根据给定的值创建一个响应式的数据对象，ref() 函数调用的返回值是一个对象，这个对象上只包含一个 .value 属性</p><h2 id="5-isRef"><a href="#5-isRef" class="headerlink" title="5.isRef"></a>5.isRef</h2><p>isRef() 用来判断某个值是否为 ref() 创建出来的对象；应用场景：当需要展开某个可能为 ref() 创建出来的值的时候</p><h2 id="6-toRefs"><a href="#6-toRefs" class="headerlink" title="6.toRefs"></a>6.toRefs</h2><p>toRefs() 函数可以将 reactive() 创建出来的响应式对象，转换为普通的对象，只不过，这个对象上的每个属性节点，都是 ref() 类型的响应式数据。<br><strong>7.computed</strong></p><h2 id="8-watch"><a href="#8-watch" class="headerlink" title="8.watch"></a>8.watch</h2><p>watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作，使用之前需要按需导入。</p><h2 id="9-provide-amp-inject组件传值"><a href="#9-provide-amp-inject组件传值" class="headerlink" title="9.provide&amp;inject组件传值"></a>9.provide&amp;inject组件传值</h2><p>provide() 和 inject() 可以实现嵌套组件之间的数据传递。这两个函数只能在 setup() 函数中使用。父级组件中使用 provide() 函数向下传递数据；子级组件中使用 inject() 获取上层传递过来的数据。</p><h2 id="10-节点引用template-ref"><a href="#10-节点引用template-ref" class="headerlink" title="10.节点引用template ref"></a>10.节点引用template ref</h2><h2 id="11-nextTick"><a href="#11-nextTick" class="headerlink" title="11.nextTick"></a>11.nextTick</h2><h1 id="三。vue3为什么变快了？"><a href="#三。vue3为什么变快了？" class="headerlink" title="三。vue3为什么变快了？"></a>三。vue3为什么变快了？</h1><h2 id="vue2和3的变化"><a href="#vue2和3的变化" class="headerlink" title="vue2和3的变化"></a>vue2和3的变化</h2><p>1.响应式原理实现发生了变化。</p><p>2.新增了一些api</p><p>3.性能上发生了很大的变化：</p><p>根据尤大大的vue视频来看进行了一下方面的优化</p><p>1.diff算法上优化（让dom渲染时间缩小）</p><p>2.响应式原理的优化（减少源码量大小）</p><p>3.项目包大小的优化（vue3的cli打包后会比vue2小）</p><p>4.更好的支持typescript(这个是直接可以使用)</p><p>5.Tree shaking support：可以将无用模块“剪枝”。（模块按需加载减少包大小）</p><p>综上所述vue3会比vue2快上2到3倍（越大的项目越明显）。而且vue3（可以兼容ie11，应该是需要配置的）和vue2可以完美兼容（尤大大说不必，把项目立即升级vue3）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重排与重绘</title>
      <link href="2021/04/01/chong-pai-yu-chong-hui/"/>
      <url>2021/04/01/chong-pai-yu-chong-hui/</url>
      
        <content type="html"><![CDATA[<h1 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h1><p>浏览器渲染页面采用的是流式布局模型<br>重排：重排也叫<strong>回流</strong>，根据渲染树每个渲染对象的信息，计算出各自渲染对象的几何信息，并将其安置在界面中的正确位置。<br>总结会引起重排的操作有：</p><ol><li>页面首次渲染</li><li>浏览器窗口大小发生改变、</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或删除可见的DOM元素</li><li>激活CSS伪类</li><li>设置style属性</li><li>查询某些属性或调用某些方法</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1648272127291-ec3c7c50-e060-4a8c-a4ff-5a20c59a27e6.png#clientId=ud0f3925f-2751-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua236da94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=692&originalType=url&ratio=1&rotation=0&showTitle=false&size=26702&status=done&style=none&taskId=u61a08bae-734a-4f8f-8f82-5fad998311b&title=" alt="image.png"></p><h1 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h1><p>重绘：当页面中元素样式的改变并不影响它在文档流中的位置时，例如：更改字体颜色<br><img src="https://cdn.nlark.com/yuque/0/2022/png/510079/1648272240010-b9f565ae-6aa9-4a2c-ad6c-a3d12568a764.png#clientId=ud0f3925f-2751-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u69b40d25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=585&originalType=url&ratio=1&rotation=0&showTitle=false&size=14371&status=done&style=none&taskId=ucc63d595-eae3-441e-8077-8d8635c38d8&title=" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css选择器及权重</title>
      <link href="2021/03/22/css-xuan-ze-qi-ji-quan-chong/"/>
      <url>2021/03/22/css-xuan-ze-qi-ji-quan-chong/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1616385718065-1509deee-8d2f-447d-b582-469a0ee47c80.gif#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=250&originWidth=312&size=226098&status=done&style=none&width=312" alt="1.gif"></h1><h1 id="一，选择器的详解"><a href="#一，选择器的详解" class="headerlink" title="一，选择器的详解"></a>一，选择器的详解</h1><p><strong>1.标签选择器（元素选择器）：</strong><br>通过HTML的标签作为选择器，作用于选取的HTML文档相同的HTML元素。<br>如：p{}；<br><em><strong>————————————————————————————————————————</strong></em><br><strong>2.类选择器：</strong><br>第一步：设置类名&lt;开始标签 class = “类名”&gt;&lt;/结束标签&gt;<br>第二步：为类设置样式    .类名{};<br>注意：<br><em>1.同一文档中的类名可以相同。</em><br><em>2.class后面可以设置有很多值，用空格分开。</em><br><em>————————————————————————————————————————</em><br><strong>3.id选择器：</strong><br>第一步：设置id名&lt;开始标签  id=”类名”&gt;&lt;/结束标签&gt;<br>第二步：设置样式    #ID名字{}；<br><strong>注意：</strong><br><em>1.同一文档中，id名必须唯一。</em><br><em>2.id的权重大于class。</em><strong>————————————————————————————————————————</strong>_<br>*<em>4.全局选择器（通配符选择器）：******</em>，选取文档中的所有元素。<br><em><strong>————————————————————————————————————————</strong></em><br><strong>5.群组选择器：</strong><br>将多个选择器用逗号连在一起，形成一个组，使他们应用同样的样式。<br>如：p，h1{}；<br><em><strong>————————————————————————————————————————</strong></em><br><strong>6.伪类选择器：</strong><br>1.  :link      设置超链接的默认效果<br>2.  :visited    设置超链接被访问过后的样式<br>3.  :hover     设置元素被鼠标滑过的样式<br>4.  :active      设置元素被激活时的样式<br>5.  :focus      设置元素获得输入焦点时的样式<em><strong>————————————————————————————————————————</strong></em><br><strong>7.后代选择器：</strong><br>用来选择一个元素的所有后代元素，选择器间用空格分隔。<br>如:div p{}；<br><em><strong>————————————————————————————————————————</strong></em><br><strong>8.子代选择器：</strong><br>用来选择一个元素的子代元素，两个选择器间用&gt;分隔。<br>如：div&gt;p{};<br><em><strong>————————————————————————————————————————</strong></em><br><strong>9.属性选择器：</strong><br>通过元素的属性或者属性值来获取元素。</p><ol><li>a.[属性名]{样式}      选取具有某个属性的所有元素</li><li>b.匹配元素[属性名]{样式}    选取具有某个属性且匹配前面的“匹配元素”的所有元素</li><li>c.[属性名1][属性名2]{样式}  选取具有多个属性的所有元素</li><li>e.[属性名=”属性值”]{样式}       选取具有某个属性且具有指定属性值的所有元素</li><li>f.[属性名~=”属性值1  属性值2  属性值3…”]   选取具有某个属性且包含 某个属性值的所有元素</li><li>g.[属性名|=”属性值”]    选取具有某个属性，且其属性值以某些字符串作为前缀，或属性值为该字符串，如</li><li>   <p title="a-1">测试1</p></li><li>   <p title="a">测试2</p></li><li>   [title|=”a”]{}，会选取到测试1和测试2</li><li>h.[属性名^=”字符串”]    选取具有某个属性，且属性值以某些字符开头的所有元素</li><li>i.[属性名$=”字符串”]   选取具有某个属性，且属性值以某些字符串做结尾的所有元素</li><li>j.[属性名*=”字符串”]    选取具有某个属性，且属性值中包含指定字符串的所有元素</li></ol><p><em><strong>————————————————————————————————————————</strong></em><br><strong>10.交集选择器：</strong><br>将两个选择器紧挨着写在一起，作用是选择这两个选择器的交集部分，格式有三种。<br>1.a.标签选择器.类名<br>2.b.标签选择器#id名<br>3.c.标签选择器[属性名=”属性值”]<br><em><strong>————————————————————————————————————————</strong></em><br><strong>11.结构为类选择器：</strong><br>用于选取一个结构的某个元素。</p><ol><li>:first-child           选取结构中第一个元素</li><li>父元素  :first-child       选取某个结构中的第一个元素</li><li>父元素  匹配对象:first-child       选取某个机构中的第一个元素，且这个元素必须和匹配对象向匹配</li><li>:last-child        选取结构中最后一个元素</li><li>:nth-child(n)          选取结构中第n个元素</li><li>:nth-last-child(n)        选取结构中倒数第n个元素</li><li>元素类型:nth-of-type(n)       按类别查找结构中的第n个元素</li><li>元素类型：nth-last-of-type(n)     按类型在结构中查找倒数第n个元素</li><li>元素类型：first-of-type        按类型查找结构中第一个符合某种类型的元素</li><li>元素类型：last-of-type         按类型查找结构中最后一个符合某种类型的元素</li></ol><p><em><strong>————————————————————————————————————————</strong></em><br>**12.伪元素选择器：</p><ol><li>:first-letter   选取一个元素的第一个字符  </li><li>:first-line 选取一个元素的第一行内容</li><li>:before     在一个元素前面插入相应内容，常和content结合使用</li><li>:after      在一个元素后面插入内容，常和content结合使用</li></ol><p><strong>注意:</strong><br><em>:first-line</em><br><em>:first-letter</em><br><em>这两个选择器的应用对象是块级元素</em><br><em><strong>————————————————————————————————————————</strong></em><br><strong>13.Ui选择器：</strong></p><ol><li>:enabled     选取界面中的可用元素</li><li>:disabled    选择界面中不可用元素</li></ol><p><em><strong>————————————————————————————————————————</strong></em><br><strong>14.通用兄弟元素选择器：</strong></p><ol><li>选择器1<del>选择器2     选取的是选择器1后面的所有选择器2，如div</del>p，选取的是div后面的所有p元素</li><li>选择器1+选择器2     选取的是选择器1后面的第一个选择器2元素，如div+p，选取的是div后面的第一个p元素</li><li>:root   选取文档的根元素，即<html>标签</li><li>:empty  选取文档中的空元素（所谓空元素，就是指该元素中连文本性信息都没有）</li><li>:not(被否定的元素)   否定伪类选择器，用来排除某些元素</li></ol><p>  6:target   选取文档中具有锚点的元素，当超链接被激活时发挥作用<br><em><strong>————————————————————————————————————————<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1616385757947-71bc02a2-6023-4753-8e87-23ecd4ed3c60.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=1%20%2813%29.jpeg&originHeight=300&originWidth=300&size=9728&status=done&style=none&width=300" alt="1 (13).jpeg"></strong></em></p><h1 id="二，选择器的权重问题"><a href="#二，选择器的权重问题" class="headerlink" title="二，选择器的权重问题"></a>二，选择器的权重问题</h1><ol><li>标签选择器的权重为0001</li><li>class选择器的权重为0010</li><li>id选择器的权重为0100</li><li>属性选择器的权重为0010</li><li>伪类选择器的权重为0010</li><li>伪元素选择器的权重为0010</li><li>包含选择器的权重：所包含选择器的权重之和</li><li>子选择器的权重：所包含选择器的权重之和</li><li>交集选择器权重为选择器之和</li><li>继承样式的权重为0000</li><li>行内样式的权重为1000<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1616385786438-f03ddb2f-1a13-4b7a-817d-626729971a92.jpeg#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&name=%E4%B8%AD%E4%BA%8C%E9%9D%92%E5%B9%B4%F0%9F%90%B1_%F0%9F%91%93%20%281%29.jpeg&originHeight=240&originWidth=240&size=17156&status=done&style=none&width=240" alt="中二青年🐱_👓 (1).jpeg"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🎈CSS样式----浮动</title>
      <link href="2021/03/22/css-yang-shi-fu-dong/"/>
      <url>2021/03/22/css-yang-shi-fu-dong/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1615994560128-4ecb8031-54e2-4714-9069-3839a60127f1.jpeg#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&name=1%20%282%29.jpeg&originHeight=225&originWidth=400&size=6728&status=done&style=none&width=400" alt="1 (2).jpeg"></p><h3 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h3><ul><li>标准文档流</li><li>浮动的性质</li><li>浮动的清楚<h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3>宏观的讲，我们的web页面和Photoshop等设计软件有本质的区别：文本页面的制作，是个“流”，必须从上而下，像“织毛衣”。而设计软件，像往哪里画个东西，都能画。<h4 id="标准文档流的特性"><a href="#标准文档流的特性" class="headerlink" title="标准文档流的特性"></a>标准文档流的特性</h4><h6 id="1-空白折叠现象："><a href="#1-空白折叠现象：" class="headerlink" title="1.空白折叠现象："></a>1.空白折叠现象：</h6>无论多少个空格、换行、tab，都会折叠为一个空格。<br>比如，如果我们想让img标签之间没有空隙，必须紧密连接：<br><code>&lt;img src=&quot;img/1.png&quot; /&gt;&lt;img src=&quot;img/2.png&quot; /&gt;&lt;img src=&quot;img/3.png&quot; /&gt;</code><h6 id="2-高矮不齐，底边对齐："><a href="#2-高矮不齐，底边对齐：" class="headerlink" title="2.高矮不齐，底边对齐："></a>2.高矮不齐，底边对齐：</h6>举例如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1615995729754-52202d1a-483e-4bb7-9c38-0109d15103fe.png#align=left&display=inline&height=644&margin=%5Bobject%20Object%5D&originHeight=644&originWidth=780&size=0&status=done&style=none&width=780"></li></ul><h6 id="3-自动换行，一行不满，换行写。"><a href="#3-自动换行，一行不满，换行写。" class="headerlink" title="3.自动换行，一行不满，换行写。"></a>3.自动换行，一行不满，换行写。</h6><h4 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h4><p>标准文档流等级森严。标签分为两种等级：</p><ul><li><p>行内元素</p></li><li><p>块级元素</p><h4 id="行内元素和块级元素的区别："><a href="#行内元素和块级元素的区别：" class="headerlink" title="行内元素和块级元素的区别："></a>行内元素和块级元素的区别：</h4><p>行内元素：</p></li><li><p>与其他行内元素并排</p></li><li><p>不能设置宽。高。默认的宽度就是文字的宽度。</p></li></ul><p>块级元素：</p><ul><li>霸占一行，不能与其他任何元素并排；</li><li>能接受宽高，如果不设置宽默认变为父亲的100%。<h4 id="行内元素和块级元素的分类："><a href="#行内元素和块级元素的分类：" class="headerlink" title="行内元素和块级元素的分类："></a>行内元素和块级元素的分类：</h4><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1615995729758-d3ec2e07-200b-4802-a9cf-eab280d7bb00.png#align=left&display=inline&height=494&margin=%5Bobject%20Object%5D&originHeight=494&originWidth=572&size=0&status=done&style=none&width=572"></li></ul><h4 id="行内元素和块级元素的相互转换："><a href="#行内元素和块级元素的相互转换：" class="headerlink" title="行内元素和块级元素的相互转换："></a>行内元素和块级元素的相互转换：</h4><p>我们可以通过display属性将块级元素和行内元素进行相互转换。display即“显示模式”。</p><h5 id="块级元素可以转换行内元素："><a href="#块级元素可以转换行内元素：" class="headerlink" title="块级元素可以转换行内元素："></a>块级元素可以转换行内元素：</h5><p>如：（给一个div设置）<br>display：inline；<br>此时特和span无异。</p><h5 id="行内元素可以转换块级元素："><a href="#行内元素可以转换块级元素：" class="headerlink" title="行内元素可以转换块级元素："></a>行内元素可以转换块级元素：</h5><p>如：（给一个span设置）<br>display：block；<br>此时特和div无异。</p><p><strong>标准流里面的限制非常多，导致很多页面效果无法实现。如果我们现在就要并排、并且就要设置宽高，那该怎么办呢？办法是：**</strong>移民！**<strong>脱离标准流**</strong>！**<br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1615996077276-12c4ece7-48e5-41b7-8763-9aae5dfc4e3e.jpeg#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&name=%E6%88%91%E7%9A%84%E5%A4%A9%E5%91%A2%F0%9F%98%AE%20%286%29.jpeg&originHeight=400&originWidth=400&size=16410&status=done&style=none&width=222" alt="我的天呢😮 (6).jpeg"></strong><br><strong>css中一共有三种手段，使一个元素脱离标准文档流：</strong><br>**</p><ul><li>浮动</li><li>绝定位</li><li>固定定位</li></ul><p>这便引出我们今天要学的内容：浮动🎈</p><h3 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h3><p>浮动是css里面布局用的最多的属性。<br>现在有两个div，分别设置宽高。我们知道，它们的效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1615996337626-8d1486b8-3c76-47a0-8e0d-7b0837627c2d.png#align=left&display=inline&height=347&margin=%5Bobject%20Object%5D&originHeight=646&originWidth=917&size=0&status=done&style=none&width=492"><br>此时，如果给这两个div增加一个浮动属性，比如<code>float: left;</code>，效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1615996361973-b7b63600-df23-4053-9975-9b9ee66d8fb4.png#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&originHeight=646&originWidth=901&size=0&status=done&style=none&width=495"><br>这就达到了浮动的效果。此时，两个元素并排了，并且两个元素都能够设置宽度、高度了。<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1615996442128-f105f10f-679f-4395-adb4-8978cbc032f4.gif#align=left&display=inline&height=135&margin=%5Bobject%20Object%5D&name=%E6%88%91%E7%9A%84%E5%A4%A9%E5%91%A2%F0%9F%98%AE%20%281%29.gif&originHeight=135&originWidth=170&size=115426&status=done&style=none&width=170" alt="我的天呢😮 (1).gif"></p><h3 id="浮动的三个性质："><a href="#浮动的三个性质：" class="headerlink" title="浮动的三个性质："></a>浮动的三个性质：</h3><h4 id="性质1：浮动的元素脱标"><a href="#性质1：浮动的元素脱标" class="headerlink" title="性质1：浮动的元素脱标"></a>性质1：浮动的元素脱标</h4><p>脱标即脱离标准流。我来看一下脱标实例：<br>证明1：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616070379825-a3f744a9-fbbc-4a92-8686-873cb2982497.png#align=left&display=inline&height=462&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=749&size=0&status=done&style=none&width=749"><br>证明2：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616070437843-7ffbac33-ae33-44f2-a907-1527a3d0ffdc.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1019&size=0&status=done&style=none&width=1019"><br>上图中，span标签在标准流中，是不能设置宽高的（因为是行内元素）。但是，一旦设置为浮动之后，即使不转成块级元素，也能够设置宽高了。<br>所以能够证明一件事：<strong>一旦一个元素浮动了，那么，将能够并排了，并且能够设置宽高了。无论它原来是个div还是个span。</strong>所有标签，浮动之后，已经不区分行内、块级了。<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1616070543088-76e20500-5efb-4805-bd1a-97c57fe34161.gif#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=150&originWidth=148&size=15960&status=done&style=none&width=148" alt="1.gif"></p><h4 id="性质2：浮动的元素相互贴靠"><a href="#性质2：浮动的元素相互贴靠" class="headerlink" title="性质2：浮动的元素相互贴靠"></a>性质2：浮动的元素相互贴靠</h4><p>给三个div均设置了<code>float: left;</code>属性之后，然后设置宽高。当改变浏览器窗口大小时，可以看到div的贴靠效果：<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1616070630370-bf82d0cd-6a68-42d3-b69e-44033e9b5b4c.gif#align=left&display=inline&height=1292&margin=%5Bobject%20Object%5D&originHeight=1292&originWidth=1180&size=0&status=done&style=none&width=1180"><br>上图显示，3号如果有足够空间，那么就会靠着2号。如果没有足够的空间，那么会靠着1号大哥。<br>如果没有足够的空间靠着1号大哥，3号自己去贴左墙。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1616070704080-ad0dfa1c-d7ca-4efb-a65d-ab08878c473e.gif#align=left&display=inline&height=1276&margin=%5Bobject%20Object%5D&originHeight=1276&originWidth=1060&size=0&status=done&style=none&width=1060"></p><p>上图显示，3号贴左墙的时候，并不会往1号里面挤。<br>同样，float还有一个属性值是<code>right</code>，这个和属性值<code>left</code>是对称的。</p><h4 id="性质3：浮动的元素有“字围”效果"><a href="#性质3：浮动的元素有“字围”效果" class="headerlink" title="性质3：浮动的元素有“字围”效果"></a>性质3：浮动的元素有“字围”效果</h4><p>我们让div浮动，p不浮动。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616070793926-aa1a7e7c-45fe-4fe5-bc1d-e704ef49b335.png#align=left&display=inline&height=696&margin=%5Bobject%20Object%5D&originHeight=696&originWidth=1044&size=0&status=done&style=none&width=1044"><br>上图中，我们发现：<strong>div挡住了p，但不会挡住p中的文字</strong>，形成“字围”效果。<br>总结：<strong>标准流中的文字不会被浮动的盒子遮挡住</strong>。（文字就像水一样）<br>关于浮动我们要强调一点，浮动这个东西，为避免混乱，我们在初期一定要遵循一个原则：<strong>永远不是一个东西单独浮动，浮动都是一起浮动，要浮动，大家都浮动。</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1616070862619-889790ea-1547-47f2-a577-3eb7cafc67a8.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=%E6%88%91%E7%9A%84%E5%A4%A9%E5%91%A2%F0%9F%98%AE%20%283%29.jpeg&originHeight=300&originWidth=303&size=12634&status=done&style=none&width=303" alt="我的天呢😮 (3).jpeg"></strong></p><h4 id="性质4-收缩"><a href="#性质4-收缩" class="headerlink" title="性质4:收缩"></a>性质4:收缩</h4><p>收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616070943013-ad271f4e-260e-4f9b-b3ec-f85bc86995f9.png#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&originHeight=351&originWidth=631&size=0&status=done&style=none&width=631"><br>div本身是块级元素，如果不设置width，它会单独霸占整行；但是，设置div浮动后，它会收缩。、</p><h4 id="浮动的补充（做网站时注意）"><a href="#浮动的补充（做网站时注意）" class="headerlink" title="浮动的补充（做网站时注意）"></a>浮动的补充（做网站时注意）</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071048365-8d0ac609-dc00-40cd-927d-83770b6cef47.png#align=left&display=inline&height=769&margin=%5Bobject%20Object%5D&originHeight=769&originWidth=913&size=0&status=done&style=none&width=913"><br>上图所示，将para1和para2设置为浮动，它们是div的儿子。此时para1+para2的宽度小于div的宽度。效果如上图所示。可如果设置para1+para2的宽度大于div的宽度，我们会发现，para2掉下来了：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071120892-5d66b8e8-6ded-4167-b2c1-fb95fe8a1ece.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&originHeight=737&originWidth=890&size=0&status=done&style=none&width=890"></p><h3 id="浮动的清除"><a href="#浮动的清除" class="headerlink" title="浮动的清除"></a>浮动的清除</h3><p>这里所说的清除浮动，指的是清除浮动与浮动之间的影响。</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>网页就是通过浮动实现并排的。<br>比如一个网页有header、content、footer这三个部分。就拿content部分举例子。<br>如果content的儿子浮动，但是，这个儿子又是一个全新的标准流，于是儿子的儿子仍然在标准流里。<br>从学习浮动的第一天起，我们就要明白，浮动又开始，就要有清除。</p><p>下面这个例子，有两个块级元素div，div没有任何属性，每个div里有li，效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071567021-e7c4456d-47ff-4587-8d98-403c958a8d45.png#align=left&display=inline&height=682&margin=%5Bobject%20Object%5D&originHeight=682&originWidth=952&size=0&status=done&style=none&width=952"></p><p>上面这个例子很简单。可如果我们给里面的 li 标签加浮动。效果却成了下面这个样子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071623080-fbaf5cd4-6cfe-47d4-ba6a-3414254a02b4.png#align=left&display=inline&height=848&margin=%5Bobject%20Object%5D&originHeight=848&originWidth=975&size=0&status=done&style=none&width=975"></p><p>上图中，我们发现：第二组中的第1个li，去贴靠第一组中的最后一个li了（我们本以为这些li会分成两排）。<br>这便引出我们要讲的：清除浮动的第一种方式。</p><h4 id="方法1：给浮动元素的祖先元素加高度"><a href="#方法1：给浮动元素的祖先元素加高度" class="headerlink" title="方法1：给浮动元素的祖先元素加高度"></a>方法1：给浮动元素的祖先元素加高度</h4><p>造成前言中这个现象的根本原因是：li的<strong>父亲div没有设置高度</strong>，导致这两个div的高度均为0px（我们可以通过网页的审查元素进行查看）。div的高度为零，导致不能给自己浮动的孩子，撑起一个容器。<br>撑不起一个容器，导致自己的孩子没办法在自己的内部进行正确的浮动。<br>现在就算给这个div设置高度，可如果div自己的高度小于孩子的高度，也会出现不正常的现象：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071815929-580cdbc2-4829-466b-bb5b-3f6ff9aed284.png#align=left&display=inline&height=877&margin=%5Bobject%20Object%5D&originHeight=877&originWidth=996&size=0&status=done&style=none&width=996"></p><p>给div设置一个正确的合适的高度（至少保证高度大于儿子的高度），就可以看到正确的现象：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616071848559-c56b6b5e-6bb9-4a5b-b119-c6af926f1bf3.png#align=left&display=inline&height=902&margin=%5Bobject%20Object%5D&originHeight=902&originWidth=664&size=0&status=done&style=none&width=664"></p><p><strong>总结：</strong><br><strong>如果一个元素要浮动，那么它的祖先元素一定要有高度。</strong><br><strong>有高度的盒子，才能关住浮动</strong>。（记住这句过来人的经验之语）</p><h4 id="方法2：clear-both"><a href="#方法2：clear-both" class="headerlink" title="方法2：clear:both;"></a>方法2：clear:both;</h4><p>网页制作中，高度height其实很少出现。为什么？因为能被内容撑高！也就是说，方法1，工作中用得很少。<br>那么，能不能不写height，也把浮动清除了呢？也让浮动之间，互不影响呢？<br>这个时候，我们可以使用<code>clear:both;</code>这个属性。如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616072430720-a2f32485-08a3-4f64-b8a6-2f113eab3f30.png#align=left&display=inline&height=742&margin=%5Bobject%20Object%5D&originHeight=742&originWidth=872&size=0&status=done&style=none&width=872"></p><p>clear就是清除，both指的是左浮动、右浮动都要清除。<code>clear:both</code>的意思就是：<strong>不允许左侧和右侧有浮动对象。</strong><br>这种方法有一个非常大的、致命的问题，<strong>它所在的标签，margin属性失效了。</strong><br>margin失效的本质原因是：上图中的box1和box2，高度为零。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/510079/1616072521480-8437255d-f178-4e94-9c8d-6157fd742176.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=%E6%88%91%E7%9A%84%E5%A4%A9%E5%91%A2%F0%9F%98%AE%20%283%29.jpeg&originHeight=300&originWidth=303&size=12634&status=done&style=none&width=303" alt="我的天呢😮 (3).jpeg"></p><h4 id="方法3-：隔墙法"><a href="#方法3-：隔墙法" class="headerlink" title="方法3 ：隔墙法"></a>方法3 ：隔墙法</h4><p>上面这个例子中，为了防止第二个div贴靠到第二个div，我们可以在这两个div中间用一个新的div隔开，然后给这个新的div设置<code>clear: both;</code>属性；同时，既然这个新的div无法设置margin属性，我们可以给它设置height，以达到margin的效果（曲线救国）。这便是隔墙法。<br>我们看看例子效果就知道了：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616072715775-5111dbd2-ad4e-4f99-9548-53532c3d7639.png#align=left&display=inline&height=776&margin=%5Bobject%20Object%5D&originHeight=776&originWidth=1017&size=0&status=done&style=none&width=1017"></p><h5 id="内墙法："><a href="#内墙法：" class="headerlink" title="内墙法："></a>内墙法：</h5><p><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073076849-62466df0-2933-4390-9133-ad344a76acc3.png#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&originHeight=176&originWidth=722&size=0&status=done&style=none&width=722"><br>上面这个图非常重要，当作内墙法的公式，先记下来。<br>为了讲内墙法，我们先记住一句重要的话：<strong>一个父亲是不能被浮动的儿子撑出高度的</strong>。举例如下：<br>（1）我们在一个div里放一个有宽高的p，效果如下：（很简单）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073108176-9795775a-14c7-4179-bbc2-44c63c200556.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=861&size=0&status=done&style=none&width=861"><br>（2）可如果在此基础之上，给p设置浮动，却发现父亲div没有高度了：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073135750-161249b5-de90-4f2f-a23e-1952665a023e.png#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=911&size=0&status=done&style=none&width=911"><br>（3）此时，我么可以在div的里面放一个div（作为内墙），就可以让父亲div恢复高度：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073148328-96bd781e-ba6e-4a29-b3e8-6a140454a81c.png#align=left&display=inline&height=546&margin=%5Bobject%20Object%5D&originHeight=546&originWidth=874&size=0&status=done&style=none&width=874"><br>于是，我们采用内墙法解决前言中的问题：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073170330-e4b9885c-d3f3-4b57-b30e-9cd4e0c34991.png#align=left&display=inline&height=697&margin=%5Bobject%20Object%5D&originHeight=697&originWidth=892&size=0&status=done&style=none&width=892"><br>与外墙法相比，内墙法的优势（本质区别）在于：内墙法可以给它所在的家撑出宽度（让box1有高）。即：box1的高度可以自适应内容。<br>而外墙法，虽然一道墙可以把两个div隔开，但是这两个div没有高，也就是说，无法wrap_content。</p><h4 id="方法4：overflow-hidden"><a href="#方法4：overflow-hidden" class="headerlink" title="方法4：overflow:hidden;"></a>方法4：overflow:hidden;</h4><p>属性：<br>overflow:hidden;<br>overflow即“溢出”， hidden即“隐藏”。这个属性的意思是“溢出隐藏”。顾名思义：所有溢出边框的内容，都要隐藏掉。如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073613595-26b1e666-730c-4392-9559-4cf5bb9c83b8.png#align=left&display=inline&height=432&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=1050&size=0&status=done&style=none&width=1050"></p><p>一个父亲不能被自己浮动的儿子，撑出高度。但是，只要给父亲加上<code>overflow:hidden</code>; 那么，父亲就能被儿子撑出高了。这是一个偏方。<br>举个例子：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073652892-992e83fb-001d-4d62-9252-cd6d54021569.png#align=left&display=inline&height=364&margin=%5Bobject%20Object%5D&originHeight=364&originWidth=831&size=0&status=done&style=none&width=831"><br>那么对于前言中的例子，我们同样可以使用这一属性：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/510079/1616073713207-aa6c3ab6-550c-483e-9509-48a0345b2478.png#align=left&display=inline&height=733&margin=%5Bobject%20Object%5D&originHeight=733&originWidth=861&size=0&status=done&style=none&width=861"></p><p><strong>四种清楚浮动的方法总结完了，下边总结一下！</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/gif/510079/1616073939488-40c3b0da-335b-456b-ae24-5ed42a5ec56d.gif#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=1%20%288%29.gif&originHeight=300&originWidth=300&size=392770&status=done&style=none&width=300" alt="1 (8).gif"></p><h3 id="浮动清楚的总结"><a href="#浮动清楚的总结" class="headerlink" title="浮动清楚的总结"></a>浮动清楚的总结</h3><p>浮动的元素，只能被有高度的盒子关住。 也就是说，如果盒子内部有浮动，这个盒子有高，那么妥妥的，浮动不会互相影响。</p><h4 id="1、加高法"><a href="#1、加高法" class="headerlink" title="1、加高法"></a>1、加高法</h4><p>工作上，我们绝对不会给所有的盒子加高度，这是因为麻烦，并且不能适应页面的快速变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;     <span class="comment">//设置height</span></span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;    <span class="comment">//设置height</span></span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="2、clear-both-法"><a href="#2、clear-both-法" class="headerlink" title="2、clear:both;法"></a>2、clear:both;法</h4><p>最简单的清除浮动的方法，就是给盒子增加clear:both；表示自己的内部元素，不受其他盒子的影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;   <span class="comment">//clear:both;</span></span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>浮动确实被清除了，不会互相影响了。但是有一个问题，就是margin失效。两个div之间，没有任何的间隙了。</strong></p><h4 id="3、隔墙法"><a href="#3、隔墙法" class="headerlink" title="3、隔墙法"></a>3、隔墙法</h4><p>在两部分浮动元素中间，建一个墙。隔开两部分浮动，让后面的浮动元素，不去追前面的浮动元素。<br>墙用自己的身体当做了间隙。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;cl h10&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们发现，隔墙法好用，但是第一个div，还是没有高度。如果我们现在想让第一个div，自动根据自己的儿子撑出高度，我们就要想一些“小伎俩”。<br><strong>内墙法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;cl h10&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>内墙法的优点就是，不仅仅能够让后部分的p不去追前部分的p了，并且能把第一个div撑出高度。这样，这个div的背景、边框就能够根据p的高度来撑开了。</p><h4 id="4、overflow-hidden-法"><a href="#4、overflow-hidden-法" class="headerlink" title="4、overflow:hidden;法"></a>4、overflow:hidden;法</h4><p>这个属性的本意，就是将所有溢出盒子的内容，隐藏掉。但是，我们发现这个东西能够用于浮动的清除。<br>我们知道，一个父亲，不能被自己浮动的儿子撑出高度，但是，如果这个父亲加上了overflow:hidden；那么这个父亲就能够被浮动的儿子撑出高度了。这个现象，不能解释，就是浏览器的偏方。<br>并且,overflow:hidden;能够让margin生效。</p><p>【注】：本文来自：博客园，CSDN，掘金以及自己总结和感悟等等。。🐱‍🚀🐱‍👓🐱‍🐉🐱‍💻🐱‍👤🐱‍🏍</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中reduce()的用法</title>
      <link href="2021/03/10/js-zhong-reduce-de-yong-fa/"/>
      <url>2021/03/10/js-zhong-reduce-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一-定义和用法"><a href="#一-定义和用法" class="headerlink" title="一.定义和用法"></a>一.定义和用法</h1><p>reduce()方法接受一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br>reduce()可以作为一个高阶函数，用于函数的compose。<br><strong>注意</strong>：reduce()对于空数组是不会执行回调函数的。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>arr.reduce(function(total, currentValue, currentIndex, arr)&#123;&#125;, initialValue);</code><br><code> </code></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p><em>function(total,currentValue, index,arr)</em> | 必需。用于执行每个数组元素的函数。<br>函数参数： |  |<br>|  |<br>|  | <strong>参数</strong> | <strong>描述</strong> |<br>|  | total | 必需。初始值，或者计算结束后的返回值 |<br>|  | currentValue | 必需。当前正在处理的数组元素 |<br>|  | currentIndex | 可选。当前元素索引 |<br>|  | arr | 可选。当前元素所属的数组对象 |<br>| initialValue | 可选。传递给函数的初始值 |  |</p><p>看上去挺TM复杂的，其实常用的参数只有两个：total和currentValue。</p><h1 id="二-实例"><a href="#二-实例" class="headerlink" title="二.实例"></a>二.实例</h1><p>先提供一个原始数组：<br><code>var arr = [3,9,4,3,6,0,9];</code><br>实现一下需求的方式有很多，其中就包含使用reduce()的求解方式，也算是实现起来比较简洁的一种吧。</p><h2 id="1-求数组想之和"><a href="#1-求数组想之和" class="headerlink" title="1.求数组想之和"></a>1.求数组想之和</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,currentValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> total+currentValue;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>由于传入了初始值0，所以开始时total的值为0，currentValue的值为数组第一项3，相加之后返回值为3作为下一轮回调的total值，然后再继续与下一个数组项相加，以此类推。</p><h2 id="2-求数组项最大值"><a href="#2-求数组项最大值" class="headerlink" title="2.求数组项最大值"></a>2.求数组项最大值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,currentValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(total,currentValue)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于未传入初始值，所以开始时total的值为数组第一项3，currentValue的值为数组第二项9，取两值最大后继续进入下一轮回调。</p><h2 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3.数组去重"></a>3.数组去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">total,currentValue</span>)</span>&#123;</span><br><span class="line">  total,indexOf(currentValue) === -<span class="number">1</span> &amp;&amp; total.push(currentValue);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;,[]);</span><br></pre></td></tr></table></figure><p>实现的基本原理如下：<br>1.初始化一个空数组<br>2.将需要去重处理的数组中的第一项在初始化数组中查找，如果找不到（空数组中肯定找不到），就将该项添加到初始化数组中<br>2.将需要去重处理的数组中的第二项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>4.。。。。<br>5.将需要去重处理的数组中的第n项在初始化数组中查找，如果找不到，就将该项继续添加到初始化数组中<br>6.将这个初始化数组返回</p><h1 id="三-其他相关方法"><a href="#三-其他相关方法" class="headerlink" title="三. 其他相关方法"></a>三. 其他相关方法</h1><h2 id="1-reduceRight"><a href="#1-reduceRight" class="headerlink" title="1.reduceRight()"></a>1.reduceRight()</h2><p>该方法用法与reduce()其实是相同的，只是遍历的顺序相反，它是从数组的最后一项开始，向前遍历到第一项。</p><h2 id="2-forEach-、map-、every-、some-和filter"><a href="#2-forEach-、map-、every-、some-和filter" class="headerlink" title="2.forEach()、map()、every()、some()和filter()"></a>2.forEach()、map()、every()、some()和filter()</h2><p>（未完）<br><strong>重点总结：</strong><br><strong>reduce()是数组的归并方法，与forEach()、map()、filter()等迭代方法一样都会对数组每一项进行遍历，但是reduce()可同时将前面数组项遍历产生的结果与当前遍历项进行运算，这一点是其他迭代方法无法企及的。</strong><br>**</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6数值的扩展</title>
      <link href="2021/03/09/es6-shu-zhi-de-kuo-zhan/"/>
      <url>2021/03/09/es6-shu-zhi-de-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二进制和八进制的表示方法"><a href="#1-二进制和八进制的表示方法" class="headerlink" title="1.二进制和八进制的表示方法"></a>1.二进制和八进制的表示方法</h1><p>ES6提供了二进制和八进制数值的新的方法，分别用前缀0b（或者0B）和0o（或者00）表示。</p><h1 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2.Number.isFinite(),Number.isNaN()"></a>2.Number.isFinite(),Number.isNaN()</h1><p>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。<br>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p><h1 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(),Number.parseFloat()"></a>3.Number.parseInt(),Number.parseFloat()</h1><p>ES6将全局方法parseInt()和parseFloat()，一直到Number对象上面，行为保持不变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure><p>这样的做法的目的，是逐步减少全局性方法，使得语言逐步模块化。</p><h1 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h1><p>Number.isInteger()用来判断一个数值是否为整数。</p><p>。<br>。<br>。</p><h1 id="7-Math对象的扩展"><a href="#7-Math对象的扩展" class="headerlink" title="7.Math对象的扩展"></a>7.Math对象的扩展</h1><p>ES6在Math对象上新增了17个与数学相关的方法。所有的这些方法都是静态方法，只能在Math对象上调用。</p><h2 id="7-1-Math-trunc"><a href="#7-1-Math-trunc" class="headerlink" title="7.1 Math.trunc()"></a>7.1 Math.trunc()</h2><p>Math.trunc方法用于去除一个数的小树部分，返回整数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure><p>对于非数值，Math.trunc内部使用Number方法将其先转数值。<br>对于空值和无法截取整数的值。返回NaN。</p><h2 id="7-2-Math-sign"><a href="#7-2-Math-sign" class="headerlink" title="7.2 Math.sign()"></a>7.2 Math.sign()</h2><p>Math.sign方法用来判断一个数到底是正数，负数，还是零。对于非数值，会将其转换为数值。<br>它会返回五种值。<br>参数为正数，返回+1；<br>。。为负数，返回-1；<br>。。为0，     返回0；<br>。。为-0，   返回-0；<br>其他值，      返回NaN；</p><h2 id="7-3-Math-cbrt"><a href="#7-3-Math-cbrt" class="headerlink" title="7.3 Math.cbrt()"></a>7.3 Math.cbrt()</h2><p>Math.cbrt()方法用于计算一个数的立方根。</p><h2 id="7-4-Math-clz32"><a href="#7-4-Math-clz32" class="headerlink" title="7.4 Math.clz32()"></a>7.4 Math.clz32()</h2><p>方法将参数转化为32位无符号正数的形式，然后返回这个32位值里面有多少个前导0；</p><h2 id="7-5-Math-imul"><a href="#7-5-Math-imul" class="headerlink" title="7.5 Math.imul()"></a>7.5 Math.imul()</h2><p>方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位带符号的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line"><span class="built_in">Math</span>.imul(-<span class="number">2</span>, -<span class="number">2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="7-6-Math-fround"><a href="#7-6-Math-fround" class="headerlink" title="7.6 Math.fround()"></a>7.6 Math.fround()</h2><p>方法返回一个数的32位单精度浮点数形式。</p><h2 id="7-7-Math-hypot"><a href="#7-7-Math-hypot" class="headerlink" title="7.7 Math.hypot()"></a>7.7 Math.hypot()</h2><p>方法返回所有参数的平方和的平方根。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;foo&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>);   <span class="comment">// 7.0710678118654755</span></span><br><span class="line"><span class="built_in">Math</span>.hypot(-<span class="number">3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="7-8-对数方法"><a href="#7-8-对数方法" class="headerlink" title="7.8 对数方法"></a>7.8 对数方法</h2><p>ES6新增了4个对数相关方法。</p><h3 id="1-Math-expm1"><a href="#1-Math-expm1" class="headerlink" title="(1)Math.expm1()"></a>(1)Math.expm1()</h3><p>Math.expm1(x)返回e的x次方-1，即Math.exp(x)-1。</p><h3 id="2-Math-log1p"><a href="#2-Math-log1p" class="headerlink" title="(2)Math.log1p()"></a>(2)Math.log1p()</h3><p>方法返回1+x的自然对数，即Math.log(x+1)。如果x小于-1，返回NaN。</p><h3 id="3-Math-log10"><a href="#3-Math-log10" class="headerlink" title="(3)Math.log10()"></a>(3)Math.log10()</h3><p>返回以10为底的x的对数。如果x小于0，则返回NaN。</p><h3 id="4-Math-log2"><a href="#4-Math-log2" class="headerlink" title="(4)Math.log2()"></a>(4)Math.log2()</h3><p>返回以2为底的x的对数。如果x小于0，则返回NaN。</p><h2 id="7-9-双曲函数方法"><a href="#7-9-双曲函数方法" class="headerlink" title="7.9 双曲函数方法"></a>7.9 双曲函数方法</h2><p>ES6新增了6个双曲函数方法。<br>Math.sinh(x) 返回x的双曲正弦<br>Math.cosh(x) 返回x的双曲余弦<br>Math.tanh(x) 返回x的双曲正切<br>Math.asinh(x) 返回x的反双曲正弦<br>Math.acosh(x) 返回x的反双曲余弦<br>Math.atanh(x) 返回x的反双曲正切</p><h1 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h1><p>ES2016新增一个指数运算符（**）。<br>注意：这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure><h1 id="9-BigInt数据类型"><a href="#9-BigInt数据类型" class="headerlink" title="9. BigInt数据类型"></a>9. BigInt数据类型</h1><h2 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介"></a>9.1 简介</h2><p>JavaScript所有数字都保存成64位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到53个二进制位（相当于16个十进制位），大于这个范围的整数，</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础知识</title>
      <link href="2021/01/20/html-ji-chu-zhi-shi/"/>
      <url>2021/01/20/html-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML基础知识"><a href="#HTML基础知识" class="headerlink" title="HTML基础知识"></a>HTML基础知识</h1><h2 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h2><p>HTML的结构一般包括<code>&lt;head&gt;</code>标签和<code>&lt;body&gt;</code>标签，<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>这两个标记符分别表示网页的头部和正文。头部中可包含页面的标题、关键词、描述说明等内容，他本身不作为内容显示，但影响网页显示的效果。<code>&lt;body&gt;&lt;/body&gt;</code>当中是网页实际显示的内容，正文标记符又被称为实体标记。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>DOCTYPE</code>声明了文档的类型</li><li><code>&lt;html&gt;</code>标签是HTML页面的根元素，该标签的结束标志位<code>&lt;/html&gt;</code>、</li><li><code>&lt;head&gt;</code>标签包含了文档的元数据（<code>meta</code>），如<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>式为utf-8。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 基础new Set</title>
      <link href="2021/01/14/es6-ji-chu-new-set/"/>
      <url>2021/01/14/es6-ji-chu-new-set/</url>
      
        <content type="html"><![CDATA[<h1 id="Es6-基础之-new-set"><a href="#Es6-基础之-new-set" class="headerlink" title="Es6 基础之 new set"></a>Es6 基础之 new set</h1><p>Set对象存储的值总是唯一的<br>Set对象方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>add</td><td>添加某个值，返回Set对象本身</td></tr><tr><td>clear</td><td>删除所有的键/值对，没有返回结果</td></tr><tr><td>delete</td><td>删除某个键，返回true、如果删除失败，返回false</td></tr><tr><td>forEach</td><td>对每个元素执行指定操作</td></tr><tr><td>has</td><td>返回一个布尔值，表示某个键是否在当前Set对象之中</td></tr></tbody></table><h2 id="Set对象作用"><a href="#Set对象作用" class="headerlink" title="Set对象作用"></a>Set对象作用</h2><ul><li>数组去重<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">[...new <span class="built_in">Set</span>(arr)];    <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>);   <span class="comment">//&quot;abc&quot;字符串去重</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;ice doughnut&#x27;</span>); <span class="comment">//Set(11) &#123;&quot;i&quot;, &quot;c&quot;, &quot;e&quot;, &quot; &quot;, &quot;d&quot;, …&#125;</span></span><br></pre></td></tr></table></figure></li><li>并集<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> union=<span class="keyword">new</span> <span class="built_in">Set</span>([...a,...b]); <span class="comment">//&#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure></li><li>交集<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x))); <span class="comment">//&#123;2,3&#125;</span></span><br></pre></td></tr></table></figure></li><li>差集<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">var</span> difference  = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));<span class="comment">// &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6之Array.frome()方法</title>
      <link href="2021/01/14/es6-zhi-array.from-fang-fa/"/>
      <url>2021/01/14/es6-zhi-array.from-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6之Array-from-方法"><a href="#ES6之Array-from-方法" class="headerlink" title="ES6之Array.from()方法"></a>ES6之Array.from()方法</h1><p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。<br>那么什么是类数组对象呢？所谓类数组对象，最基本的要求就是具有length属性的对象。</p><h2 id="1-将类数组对象转换为真正的数组："><a href="#1-将类数组对象转换为真正的数组：" class="headerlink" title="1.将类数组对象转换为真正的数组："></a>1.将类数组对象转换为真正的数组：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line"><span class="number">0</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line"><span class="number">1</span>:<span class="string">&#x27;22&#x27;</span>,</span><br><span class="line"><span class="number">2</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line"><span class="number">3</span>:[<span class="string">&#x27;jane&#x27;</span>,<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;length&#x27;</span>:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="built_in">console</span>.log(arr)     <span class="comment">//[&#x27;tom&#x27;,&#x27;22&#x27;,&#x27;男&#x27;,[&#x27;jane&#x27;,&#x27;john&#x27;,&#x27;Mary&#x27;]]</span></span><br></pre></td></tr></table></figure><p>那么，如果将上面代码中length属性去掉呢？<br>实践证明，答案会是一个长度为0的空数组。<br>这里将代码再改一下，就是具有length属性，但是对象的属性名不再是数字类型的，而是其他字符串型的，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;22&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sex&#x27;</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;friends&#x27;</span>:[<span class="string">&#x27;jane&#x27;</span>,<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;Mary&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">//[undefined,undefined,undefined,undefined]</span></span><br></pre></td></tr></table></figure><p>会发现结果长度为4，元素均为undefined的数组<br>由此可见，要将一类数组对象转换为一个真正数组，必须具备一下条件：</p><ul><li>1.该类数组对象必须具有length属性，用于指定数组的长度。如果没有length属性，那么转换后的数组是一个空数组。</li><li>2.该数组对象的属性名必须为数值型或者字符串型的数字。<br><font color = red>ps:该类数组对象的属性名可以加引导，也可以不加引导。</font></li></ul><h2 id="2-将Set结构的数据转换为真正的数组："><a href="#2-将Set结构的数据转换为真正的数组：" class="headerlink" title="2.将Set结构的数据转换为真正的数组："></a>2.将Set结构的数据转换为真正的数组：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">45</span>,<span class="number">97</span>,<span class="number">9797</span>,<span class="number">564</span>,<span class="number">134</span>,<span class="number">45642</span>]</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(set))   <span class="comment">//[12,45,97,9797,564,134,45642]</span></span><br></pre></td></tr></table></figure><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">12</span>,<span class="number">45</span>,<span class="number">97</span>,<span class="number">9797</span>,<span class="number">564</span>,<span class="number">134</span>,<span class="number">45642</span>]</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(set, <span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>)) <span class="comment">// [ 13, 46, 98, 9798, 565, 135, 45643 ]</span></span><br></pre></td></tr></table></figure><h2 id="3-将字符串转换为数组："><a href="#3-将字符串转换为数组：" class="headerlink" title="3.将字符串转换为数组："></a>3.将字符串转换为数组：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello world!&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str))  <span class="comment">//[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="4-Array-from参数是一个真正的数组："><a href="#4-Array-from参数是一个真正的数组：" class="headerlink" title="4.Array.from参数是一个真正的数组："></a>4.Array.from参数是一个真正的数组：</h2><p><code>console.log(Array.from([12,45,47,56,213,4654,154]))</code><br>像这种情况，Array.from返回一个一模一样的新数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络原理</title>
      <link href="2021/01/05/ji-suan-ji-wang-luo-yuan-li/"/>
      <url>2021/01/05/ji-suan-ji-wang-luo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络主要指的是TCP-IP协议栈"><a href="#计算机网络主要指的是TCP-IP协议栈" class="headerlink" title="计算机网络主要指的是TCP/IP协议栈"></a>计算机网络主要指的是TCP/IP协议栈</h1><blockquote><p><strong>闲聊</strong></p><blockquote><p>TCP/IP是互联网的基石，互联网时代的最伟大的发明。<br>前端后端都有涉及<br>TCP/IP技术栈有一部分都隐藏于操作系统内核态，总有藏着掖着，老是见不得人，当然容易被遗忘。</p></blockquote></blockquote><blockquote><p><strong>TCP/IP协议体系的认知</strong></p><blockquote><ul><li>一些概念<blockquote><p>内核态<br>用户态<br>应用层（接触较多）<br>数据链路层<br>数据传输对等</p></blockquote></li></ul></blockquote></blockquote><blockquote><p><strong>数据链路层</strong></p><blockquote><ul><li>以太网帧的格式</li><li>MTU（最大传输单元）概念</li><li>ARP协议、RARP协议（即地址解析和逆地址解析）<blockquote><p>一般归入链路层，网络和链路层的中间协议<br>报文格式<br>IP和MAC地址互查<br>ARP缓存</p></blockquote></li></ul></blockquote></blockquote><blockquote><p><strong>网络层</strong></p><blockquote><ul><li>掌握IP首部格式：如16位分片标识、DF不分片标志、MF更多分片标志、13位片偏移，8位生存时间TTL，16位的首部检验和等等</li><li>掌握IP分片</li><li>掌握IP选路（路由表）</li><li>掌握ICMP协议<blockquote><p>报文格式<br>报文的两大分类：查询+交错</p><blockquote><p>2种查询报文+5种差错报文</p></blockquote></blockquote></li></ul></blockquote></blockquote><blockquote><p><strong>传输层</strong></p><blockquote><ul><li>掌握UDP协议：包括特点+首部各个字段</li><li>掌握TCP协议：特点+首部字段+可靠机制</li><li>TCP链接控制机制：三次握手、四次挥手、同时打开、同时关闭、半关闭</li><li>TCP流量控制机制：滑动窗口、慢启动、拥塞避免、快速重传、快速恢复</li><li>TCP超时重传机制：各种定时器（4个）</li></ul></blockquote></blockquote><blockquote><p><strong>应用层</strong></p><blockquote><ul><li>掌握DNS协议</li><li>掌握DNS协议的名字空间</li><li>DNS指针查询（反向查找或逆向解析）基本原理</li><li>DNS缓存<blockquote><p>两条链接：控制连接+数据连接<br>两种工作模式：PASV+PORT<br>各种指令和响应码<br>FTP断点续传、匿名FTP</p></blockquote></li><li>HTTP协议<blockquote><p>报文格式：请求报文+响应报文+各种请求字段+响应头各种字段<br>http状态码</p></blockquote></li><li>HTTPS协议<blockquote><p>https详细握手过程<br>摘要算法、数字签名、数字证书的原理和过程</p></blockquote></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组扁平化</title>
      <link href="2021/01/05/shu-zu-bian-ping-hua/"/>
      <url>2021/01/05/shu-zu-bian-ping-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><p><strong>数组扁平化是指将多维数组变为一维数组：</strong><br><code>[1,[2,3,[4,5]]]   -----&gt;  [1,2,3,4,5]</code></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-reduce"><a href="#1-reduce" class="headerlink" title="1.reduce"></a>1.reduce</h3><p>遍历数组每一项，若值为数组则递归遍历，否则concat。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">result,item</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> result.concat(<span class="built_in">Array</span>.isArray(item)?flattten(item):item);</span><br><span class="line">&#125;,[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduce是数组的一种方法，它接受一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算一个值。<br>reduce包含两个参数：回调函数，传给total的初始值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求数组的各项值相加的和</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">total,item</span>)=&gt;</span>&#123; <span class="comment">//total为之前的计算结果，item为数组的各项值</span></span><br><span class="line"><span class="keyword">return</span> total+item;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="2-toString-amp-split"><a href="#2-toString-amp-split" class="headerlink" title="2.toString&amp;split"></a>2.toString&amp;split</h3><p>调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Number</span>(item);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型。</p><h3 id="3-join-amp-split"><a href="#3-join-amp-split" class="headerlink" title="3.join&amp;split"></a>3.join&amp;split</h3><p>和上面的toString一样，join也可以将数组转换为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.join(<span class="string">&#x27;,&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> paresInt(item);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h3><p>递归的遍历每一项，若为数组则继续遍历，否则concat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">res = res.concat(flatten(item));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">res.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-扩展运算符"><a href="#5-扩展运算符" class="headerlink" title="5.扩展运算符"></a>5.扩展运算符</h3><p>es6的扩展运算符能将二维数组变为一维。<br><code>[].concat(...[1,2,3,[4,5]]);     //[1,2,3,4,5]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item)))&#123;</span><br><span class="line">arr=[].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用flat"><a href="#6-使用flat" class="headerlink" title="6.使用flat()"></a>6.使用flat()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.flat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然说写了5种方法，但是核心的也只有一个：<br>遍历数arr,若arr[i]为数组则递归遍历，直至arr[i]不为数组后与之前的结果从concat。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSctipt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位详解</title>
      <link href="2021/01/02/css-ding-wei-xiang-jie/"/>
      <url>2021/01/02/css-ding-wei-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS定位详解"><a href="#CSS定位详解" class="headerlink" title="CSS定位详解"></a>CSS定位详解</h1><p><strong>CSS有个重要的基本属性，前端开发必须掌握：<code>display</code> 和<code>position</code></strong><br><code>display</code>属性指定网页的布局。两个重要的布局：弹性布局<code>flex</code>和网格布局<code>grid</code>。</p><h2 id="一、position属性的作用"><a href="#一、position属性的作用" class="headerlink" title="一、position属性的作用"></a>一、position属性的作用</h2><p><code>position</code>属性用来指定一个元素在网页上的位置，一共有5种定位方式，即<code>position</code>属性的主要五个值。</p><ul><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky</li></ul><h2 id="二、static属性值"><a href="#二、static属性值" class="headerlink" title="二、static属性值"></a>二、static属性值</h2><p><code>static</code>是<code>position</code>属性的默认值。如果省略<code>position</code>属性，浏览器就认为该元素是<code>static</code>定位。<br><strong>注意：<code>static</code>定位所导致的元素位置，是浏览器自主决定的，所以这时<code>top</code>、<code>bootom</code>、<code>left</code>、<code>right</code>这四个属性无效。</strong></p><h2 id="三、relative，absolute，fixed"><a href="#三、relative，absolute，fixed" class="headerlink" title="三、relative，absolute，fixed"></a>三、relative，absolute，fixed</h2><p><code>relative</code>、<code>absolute</code>、<code>fixed</code>这三个属性值有一个共同点，都是对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。<br>这三种定位都不会对其他元素位置产生影响，因此元素之间可能 产生重叠。</p><h3 id="3-1-relative属性值"><a href="#3-1-relative属性值" class="headerlink" title="3.1 relative属性值"></a>3.1 relative属性值</h3><p><code>relative</code>表示，相对于默认位置（即<code>static</code>时的位置）进行偏移，即定位基点是元素的默认位置。<br>它必须搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，用来指定偏移的方向和距离。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.a</span>&#123;</span></span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.b</span>&#123;</span></span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            background-color: rgb(47, 47, 196);</span><br><span class="line">            float: left;</span><br><span class="line">            position: relative;</span><br><span class="line">            top: 30px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.c</span>&#123;</span></span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            background-color: red;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/510079/1608296918973-8fe5a7c1-e325-492f-85a2-e981336508f3.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=546&size=26548&status=done&style=none&width=273" alt="image.png"><br>上面代码中，<code>div</code>元素从默认位置向下偏移<code>30px</code>(即距离顶部<code>30px</code>)。</p><h3 id="3-2-absolute属性值"><a href="#3-2-absolute属性值" class="headerlink" title="3.2 absolute属性值"></a>3.2 absolute属性值</h3><p><code>absolute</code>表示，相对于上级元素（一般是父级元素）进行偏移，即定位基点是父元素。<br>它有一个重要的限制条件：定位基点（一般是父级元素）不能是<code>static</code>定位，否则定位基点就会变成整个网页的根元素<code>html</code>。另外，<code>absolute</code>定位也必须搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span>&#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.son</span>&#123;</span></span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            background-color: rgb(47, 47, 196);</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 40px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>son<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/510079/1608296878970-7d3785a1-9c44-4709-a3f5-157b0afdfad6.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=722&size=30724&status=done&style=none&width=250" alt="image.png"><br>上面代码中，父元素是<code>relative</code>定位，子元素是<code>absolute</code>定位，所以子元素的定位基点是父元素，相对于父元素的顶部向下偏移<code>40px</code>。如果父元素是<code>static</code>定位，上例的子元素就是距离网页的顶部向下偏移<code>40px</code>。<br><strong>注意，<code>absolute</code>定位的元素会被“正常页面流”忽略，即在“正常页面流”中，该元素所占空间为零，周边元素不受影响。</strong></p><h3 id="3-3-fixed-属性值"><a href="#3-3-fixed-属性值" class="headerlink" title="3.3 fixed 属性值"></a>3.3 fixed 属性值</h3><p><code>fixed</code>表示，相对于视口（浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。<br>它如果搭配<code>top</code>，<code>bottom</code>，<code>left</code>,<code>right</code>这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p><h2 id="四、sticky-属性值"><a href="#四、sticky-属性值" class="headerlink" title="四、sticky 属性值"></a>四、sticky 属性值</h2><p><code>sticky</code>跟前面四个属性值都不一样，它会产生动态效果，很像<code>relative</code>和<code>fixed</code>的结合：一些时候是<code>relative</code>定位（定位基点是自身默认位置），另一些时候自动变成<code>fixed</code>定位（定位基点是视口）。<br>因此，它能够形成“动态固定”的效果。比如，网页的搜索工具栏，初始加载时在自己的默认位置（<code>relative</code>定位）。<br>页面向下滚动时，工具栏变成固定位置，始终停留在页面头部（<code>fixed</code>定位）。<br>等到页面重新向上滚动回到原位，工具栏也会回到默认位置。<br><code>sticky</code>生效的前提是，必须搭配<code>top</code>,<code>bootom</code>,<code>left</code>,<code>right</code>这四个属性一起使用，不能省略，否则等同于<code>relative</code>定位，不产生‘动态固定’的效果。原因是这四个属性用来定义‘偏移距离’，浏览器把它当做<code>sticky</code>的生效门槛。<br>它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分完全不可见），<code>fixed</code>定位自动切换回<code>relative</code>定位。<br>请看一下示例代码。（<strong>注意：除了已被淘汰的IE以外，其他浏览器目前都支持<code>sticky</code>。但是，Safari浏览器需要加上浏览器前缀<code>-webkit-</code>。</strong>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#toolbar&#123;</span><br><span class="line">position:-webkit-sticky;/*safari浏览器*/</span><br><span class="line">position:sticky;       /*其他浏览器*/</span><br><span class="line">top:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，页面向下滚动时，<code>#toolbar</code>的父元素开始脱离视口，一旦视口的顶部与<code>#toolbar</code>的距离小于<code>20px</code>(门槛值），<code>#toolbar</code>就会自动变成<code>fixed</code>定位，保持与视口顶部20px的距离。页面会继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code>#toolbar</code>恢复成<code>relative</code>定位。</p><h2 id="五、sticky-的应用"><a href="#五、sticky-的应用" class="headerlink" title="五、sticky 的应用"></a>五、sticky 的应用</h2><p><code>sticky</code>定位可以实现一些很有用的效果。除了上面提到“动态固定”效果，还有以下用法。</p><h3 id="5-1-堆叠效果"><a href="#5-1-堆叠效果" class="headerlink" title="5.1 堆叠效果"></a>5.1 堆叠效果</h3><p>堆叠效果（stacking）指的是页面滚动时，下方的元素覆盖上方的元素。下面是一个图片堆叠的例子，下方的图片会随着页面滚动，覆盖上方图片<br>Html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;pic1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;pic2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;pic3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">position</span>:sticky;</span><br><span class="line"><span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-表格的表头锁定"><a href="#5-2-表格的表头锁定" class="headerlink" title="5.2 表格的表头锁定"></a>5.2 表格的表头锁定</h3><p>Html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>颜色r<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Yellow<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Michelle<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>Purple<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>sticky</code>必须设在<code>&lt;th&gt;</code>元素上面，不能设在<code>&lt;thead&gt;</code>和<code>&lt;tr&gt;</code>元素，因为这两个元素没有<code>reltive</code>定位，也就无法产生<code>sticky</code>效果。</p><p>（end）</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript变量、数组</title>
      <link href="2021/01/02/javascript-shu-zu/"/>
      <url>2021/01/02/javascript-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="JS变量、数组"><a href="#JS变量、数组" class="headerlink" title="JS变量、数组"></a>JS变量、数组</h1><h2 id="一，变量"><a href="#一，变量" class="headerlink" title="一，变量"></a>一，变量</h2><p>1.ECMAScript的变量是松散型变量。</p><p>松散型变量：可以用来保存任何类型的数据，换句话来说，每个变量仅仅是一个用于保存的占位符而而已。</p><p>定义变量要是用var操作符。（var是一个关键字），后跟变量名（既是一个标识符）。<br>如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure><p>改代码就是定义了一个名字为message的变量，该变量可以保存任何类型的数据。<br><strong>注意：</strong><em>既用var操作符定义的变量将成为该变量的作用域的局部变量。</em><br>如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。<br>例如<em>;</em><br>错误例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message=<span class="string">&quot;hi&quot;</span>;<span class="comment">//局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>正确例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message=<span class="string">&quot;hi&quot;</span>;</span><br><span class="line">  alert(message);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h2 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二.数据类型"></a>二.数据类型</h2><p>1.ECMAScript中有<strong>5中简单的数据类型（也称为基本数据类型）</strong>；<br><strong>5种数据类型:Undefind,NULL,Boolean,Number,String.</strong><br><strong>还有一种复杂的数据类型：</strong>Object，（Object 本质上是由一组无序的名值对组成的。ECMAScript<br>不支持任何创建自定义类型的机制，而所有值最终都将是上述 6 种数据类型之一。）<br>1.注意：对为声明的变量，执行typeof操作符都返回了undefined值。<br><em>即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是</em><br><em>明智的选择。如果能够做到这一点，那么当 typeof 操作符返回 “undefined” 值时，</em><br><em>我们就知道被检测的变量还没有被声明，而不是尚未初始化。</em><br>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 这个变量声明之后默认取得了 undefined 值</span></span><br><span class="line"><span class="comment">// 下面这个变量并没有声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><h2 id="三-字符串"><a href="#三-字符串" class="headerlink" title="三.字符串"></a>三.字符串</h2><p>1.要把多个字符串连起来可以用+号链接；<br>2.如果变量需要连接，用+号就比较麻烦，ES6新增一种模板字符串，表示方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message=<span class="string">&#x27;你好,$&#123;name&#125;,你今年$&#123;age&#125;岁了！&#x27;</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure><h4 id="3-toUpperCase"><a href="#3-toUpperCase" class="headerlink" title="3.toUpperCase"></a>3.toUpperCase</h4><p>toUpperCase()把一个字符串全部变成大写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s.toUpperCase();<span class="comment">//\返回“HELLO”</span></span><br></pre></td></tr></table></figure><h4 id="4-toLowerCase"><a href="#4-toLowerCase" class="headerlink" title="4.toLowerCase"></a>4.toLowerCase</h4><p>toLowerCAse()把一个字符串全变成小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line">s.toLowerCase();<span class="comment">//返回“hello”</span></span><br></pre></td></tr></table></figure><h4 id="5-indexOf"><a href="#5-indexOf" class="headerlink" title="5.indexOf"></a>5.indexOf</h4><p>indexOf()会搜索指定的字符串出现的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">&quot;hello,word&quot;</span>;</span><br><span class="line">s.indexOf(<span class="string">&quot;world&quot;</span>);<span class="comment">//返回7</span></span><br><span class="line">s.indexOf(<span class="string">&quot;World&quot;</span>);<span class="comment">//没有找到的字符串，返回-1</span></span><br></pre></td></tr></table></figure><h4 id="6-substring"><a href="#6-substring" class="headerlink" title="6.substring"></a>6.substring</h4><p>substring()返回指定索引区间的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">&quot;hello,word&quot;</span>;</span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//从索引0开始到5（不包括5），返回“hello”</span></span><br><span class="line">s.substring(<span class="number">7</span>);<span class="comment">//从索引7开始到结束，返回“world”</span></span><br></pre></td></tr></table></figure><h2 id="四-数组"><a href="#四-数组" class="headerlink" title="四.数组"></a>四.数组</h2><p>1.在js中数组可以包含任何类型的数据类型，并通过索引来访问每个元素。<br>取得他的长度直接访问length属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,<span class="literal">true</span>];</span><br><span class="line">arr.length;<span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>注意：如果给arr.length附一个新的值会导致arr大小变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure><h4 id="2-indexOf"><a href="#2-indexOf" class="headerlink" title="2.indexOf"></a>2.indexOf</h4><p>与String类似，arr也可以通过indexOf()来搜索一个指定的元素的位置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">&#x27;30&#x27;</span>); <span class="comment">// 元素&#x27;30&#x27;的索引为2</span></span><br></pre></td></tr></table></figure><h4 id="3-slice"><a href="#3-slice" class="headerlink" title="3.slice"></a>3.slice</h4><p>slice()就是对应String的substring（）版本，他截取arr的部分元素，然后返回一个新的arr：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意：slice()的起止包括开始不包括结束。<br>如果不给slice（）传递参数，他就会从头到结尾截取所有的元素。利用这一点，可以容易的复制一个arr:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="4-push和pop"><a href="#4-push和pop" class="headerlink" title="4.push和pop"></a>4.push和pop</h4><p>push()向arr的末尾添加若干元素，<br>pop()则把arr得最后一个元素删掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;]</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="5-unshift和shift"><a href="#5-unshift和shift" class="headerlink" title="5.unshift和shift"></a>5.unshift和shift</h4><p>unshift()在arr头部添加若干元素。<br>shift()在arr的第一个元素删掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="6-sort"><a href="#6-sort" class="headerlink" title="6.sort"></a>6.sort</h4><p>sort()可以对当前arr进行排序，他会直接修改arr的元素位置，直接调用时，按照默认顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="7-reverse"><a href="#7-reverse" class="headerlink" title="7.reverse"></a>7.reverse</h4><p>reverse()把整个arr的元素给掉个个，颠倒一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; <span class="comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="8-splice"><a href="#8-splice" class="headerlink" title="8.splice"></a>8.splice</h4><p>splice()可以从指定的索引开始删除若干个元素，然后从该位置添加若干个元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="9-concat"><a href="#9-concat" class="headerlink" title="9.concat"></a>9.concat</h4><p>concat()把当前的arr和另一个arr链接起来，并返回新的arr：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure><p>注意：concat()并没有修改当前的arr，反而返回了一个新的arr。<br>实际上，concat()方法可以接受任意个元素和arr，并自动吧arr拆开，然后全部添加到新的arr里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="10-join"><a href="#10-join" class="headerlink" title="10.join"></a>10.join</h4><p>join()把当前的arr的每个元素都用指定的字符串链接起来，然后返回链接后的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="11-多维数组"><a href="#11-多维数组" class="headerlink" title="11.多维数组"></a>11.多维数组</h4><p>如果数组的某个元素又是一个arr，则可以形成多维数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// &#x27;A-B-C-1-2-3&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="12-filter"><a href="#12-filter" class="headerlink" title="12.filter"></a>12.filter</h4><p>把超过数组中超过2000的去掉，filter主要是返回了一个新的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1500</span>,<span class="number">1200</span>,<span class="number">2000</span>,<span class="number">2100</span>,<span class="number">1800</span>];</span><br><span class="line"><span class="keyword">var</span> newArr=arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &lt; <span class="number">2000</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTMLDOM</title>
      <link href="2021/01/02/htmldom/"/>
      <url>2021/01/02/htmldom/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-DOM-简介"><a href="#HTML-DOM-简介" class="headerlink" title="HTML DOM 简介"></a>HTML DOM 简介</h1><p><strong>HTML DOM定义了访问和操作HTML文档标准</strong></p><p>如果想要学习该知识用该具备的知识：</p><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul><h1 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h1><p><strong>DOM是W3C（万维网联盟）的标准。</strong></p><p>DOM定义了访问HTML和XML文档的标准：</p><p>“W3C文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p><p>W3C DOM标准被分为3个不同的部分：</p><ul><li>核心DOM - 针对任何结构化文档的标准模型</li><li>XML DOM - 针对XML文档的标准模型</li><li>HTML DOM - 针对HTML文档的标准模型</li></ul><h1 id="什么是HTML-DOM？"><a href="#什么是HTML-DOM？" class="headerlink" title="什么是HTML DOM？"></a>什么是HTML DOM？</h1><p>HTML DOM是：</p><ul><li>HTML的标准对象模型</li><li>HTML的标准编程接口</li><li>W3C标准</li></ul><p>HTML DOM定义了所有HTML元素的<strong>对象</strong>和<strong>属性</strong>，以及访问他们的<strong>方法</strong>。</p><p><strong>HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准。</strong></p><h1 id="HTML-DOM节点"><a href="#HTML-DOM节点" class="headerlink" title="HTML DOM节点"></a>HTML DOM节点</h1><p><strong>在HTML DOM中，所有事物都是节点。DOM是被视为节点树的HTML。</strong></p><h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2><p>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点：</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素是元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性是属性节点</li><li>注释是注释节点</li></ul><h2 id="HTML-DOM节点树"><a href="#HTML-DOM节点树" class="headerlink" title="HTML DOM节点树"></a>HTML DOM节点树</h2><p>HTML DOM将HTML文档视作树结构，这种接否被称为<strong>节点树：</strong></p><p><strong>HTML DOM Tree实例</strong></p><p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif#alt=HTML%20DOM"></p><p>通过HTML DOM，树中的所有节点均可通过JavaScript进行访问。所有HTML元素（节点）均可被修改，也可以被创建和删除。</p><h2 id="节点父、子和同胞"><a href="#节点父、子和同胞" class="headerlink" title="节点父、子和同胞"></a>节点父、子和同胞</h2><p>节点树中的节点彼此拥有层级关系。</p><p>父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞节点（兄弟或姐妹）。</p><ul><li>在节点树中，顶端节点被称为根（root）</li><li>每个节点都有父节点、除了根节点（他没有父节点）</li><li>一个节点可拥有任意数量的子</li><li>同胞是拥有形同父节点的节点</li></ul><p>树的一部分，以及节点之间的关系：</p><p><img src="https://www.w3school.com.cn/i/dom_navigate.gif#alt=%E8%8A%82%E7%82%B9%20%E5%85%B3%E7%B3%BB"></p><p><strong>看下面的HTML代码片段：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM 教程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一课<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的HTML中：</p><ul><li><p>节点没有父节点；它是根节点</p></li><li><p>和的父节点是节点</p></li><li><p>文本节点”Hello world!”的父节点是节点</p></li></ul><p>并且：</p><ul><li> 节点拥有两个子节点：和</li><li>节点拥有一个子节点：节点</li><li>&lt;title&gt;节点也拥有一个子节点：文本节点”DOM教程”</li><li>&lt;h1&gt;和节点是同胞节点，同时也是的子节点</li></ul><h1 id="HTML-DOM-方法"><a href="#HTML-DOM-方法" class="headerlink" title="HTML DOM 方法"></a>HTML DOM 方法</h1><p><strong>方法是我们可以在节点（HTML元素）上执行的动作。</strong></p><h2 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h2><p>可以通过JavaScript（以及其他编程语言）对HTML DOM进行访问。</p><p>所有HTML元素被定义为对象，而编程接口则是对象方法和对象属性。</p><p>方法是您能够执行的动作（比如添加或修改元素）</p><p>属性是您能够获取或设置的值（比如节点的名称或内容）。</p><h3 id="getElementById-方法"><a href="#getElementById-方法" class="headerlink" title="getElementById()方法"></a>getElementById()方法</h3><p>getElementById()方法返回带有指定ID的元素：</p><p><strong>例子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.getElementById(<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="HTML-DOM对象-方法和属性"><a href="#HTML-DOM对象-方法和属性" class="headerlink" title="HTML DOM对象 - 方法和属性"></a>HTML DOM对象 - 方法和属性</h3><p>一些常用的HTML DOM方法：</p><ul><li>getElementById(id) - 获取带有指定ID的节点（元素）</li><li>appendChild(node) - 插入新的子节点（元素）</li><li>removeChild(node) - 删除子节点（元素）</li></ul><p>一些常用的HTML DOM属性：</p><ul><li>innerHTML - 节点（元素）的文本值</li><li>parentNode - 节点（元素）的父节点</li><li>childNodes - 节点（元素）的子节点</li><li>attribute - 节点（元素）的属性节点</li></ul><h2 id="一些DOM对象方法"><a href="#一些DOM对象方法" class="headerlink" title="一些DOM对象方法"></a>一些DOM对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getElementById()</td><td>返回带有指定ID的元素</td></tr><tr><td>getElementByTagName()</td><td>返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。</td></tr><tr><td>getElementByClassName()</td><td>返回包含带有指定雷鸣的所有的节点列表</td></tr><tr><td>appendChild()</td><td>把新的子节点添加到指定节点。</td></tr><tr><td>removeChild()</td><td>删除子节点 。</td></tr><tr><td>replaceChild()</td><td>替换子节点</td></tr><tr><td>insertBefore()</td><td>在指定的子节点前面插入新的子节点</td></tr><tr><td>createAttribute()</td><td>创建属性节点</td></tr><tr><td>createElement()</td><td>创建元素节点</td></tr><tr><td>createTextNode()</td><td>创建文本节点</td></tr><tr><td>getAttribute()</td><td>返回指定属性值</td></tr><tr><td>setAttribute()</td><td>把指定属性设置或修改为指定的值</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组去重</title>
      <link href="2020/12/30/javascript-shu-zu-qu-chong/"/>
      <url>2020/12/30/javascript-shu-zu-qu-chong/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript数组去重"><a href="#JavaScript数组去重" class="headerlink" title="JavaScript数组去重"></a>JavaScript数组去重</h1><p>数组去重，一般都是在面试题上看到，一般是要求手写数组去重方法的代码。如果被提问到数组去重的方法有哪些？如果你能回答出十种方法，面试官可能会对你刮目相看。<br>在真实的项目中碰到的数组去重，一般都是后台去处理，很好让前端处理数组去重。虽然日常项目用到的概率比降低，但还是需要了解一下，以防面试的时候可能回被问到。</p><h2 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h2><h3 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>注：不考虑兼容性，这种去重的方法代码最少。这种方法还是无法去掉“{}”空对象，后面的高级方法会添加去掉重复的“{}”的方法。</strong></p><h3 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]==arr[j])&#123;</span><br><span class="line">arr.splice(j,<span class="number">1</span>);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure><p><strong>双层循环，外层循环元素，内层循环时比较值。值相同时，则删除这个值。</strong></p><h3 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr))&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;不是数组&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> array=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array.indexOf(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">array.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure><p><strong>新建一个空的结果数组，for循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进树组。</strong></p><h3 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr))&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;不是数组&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">arr = arr.sort()</span><br><span class="line"><span class="keyword">var</span> array = [arr[<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]!==arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">array.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]      //NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure><p><strong>利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</strong></p><h3 id="五、利用includes"><a href="#五、利用includes" class="headerlink" title="五、利用includes"></a>五、利用includes</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(arr))&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array= [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!array.includes(arr[i]))&#123;</span><br><span class="line">    array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure><h3 id="六、利用hasOwnProperty"><a href="#六、利用hasOwnProperty" class="headerlink" title="六、利用hasOwnProperty"></a>六、利用hasOwnProperty</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item+item)?fasle : (obj[<span class="keyword">typeof</span> item + item]=<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了</span></span><br></pre></td></tr></table></figure><p><strong>利用hasOwnPeoperty判断是否存在对象属性</strong></p><h3 id="七、利用filter"><a href="#七、利用filter" class="headerlink" title="七、利用filter"></a>七、利用filter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="comment">//当前元素，在原始数组中的第一个索引==当前索引，否则返回当前元素</span></span><br><span class="line"><span class="keyword">return</span> arr.indexOf(item,<span class="number">0</span>)===index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="八、利用递归去重"><a href="#八、利用递归去重" class="headerlink" title="八、利用递归去重"></a>八、利用递归去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> array=arr;</span><br><span class="line"><span class="keyword">var</span> len=array.length;</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;    <span class="comment">//排序后更加方便去重</span></span><br><span class="line"><span class="keyword">return</span> a,b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[index]===array[index-<span class="number">1</span>])&#123;</span><br><span class="line">array.splice(index,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">loop(index,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">loop(len-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</span></span><br></pre></td></tr></table></figure><h3 id="九、利用Map数据结构去重"><a href="#九、利用Map数据结构去重" class="headerlink" title="九、利用Map数据结构去重"></a>九、利用Map数据结构去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//数组用于返回结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.has(arr[i]))&#123;    <span class="comment">//如果有该key值</span></span><br><span class="line">map.set(arr[i],<span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> map.set(arr[i],<span class="literal">false</span>);     <span class="comment">//如果没有key值</span></span><br><span class="line"> array.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined]</span></span><br></pre></td></tr></table></figure><p><strong>创建一个空的Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现不同的key值，所以最终得到的结果就是去重后的结果。</strong></p><h3 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>prev,includes(cur)?prev:[...prev,cur],[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure><p>注：这些方法都是面试时候经常问到的JS问题应该多看啊<br>（end）</p>]]></content>
      
      
      <categories>
          
          <category> JavaSctipt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
